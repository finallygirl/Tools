 1. OC相对于C
    a. 在C的基础上新增了一小部分面向对象的语法。
    b. 将C的复杂的，繁琐的语法封装的更为简单。
    c. OC完全兼容C语言。
 
 2. OC程序的源文件的后缀名是.m m代表message 代表OC中最重要的一个机制 消息机制。
    C程序的源文件的后缀名.c
 
 3. main函数仍然是OC程序的入口和出口。
    int类型的返回值 代表程序的结束状态。
    main函数的参数：仍然可以接受用户在运行程序的时候传递数据给程序。
                  参数可以不要。
 
 4. #import指令。
 1). 以#号开头， 是一个预处理指令。(预处理指令执行时机在编译之前)
 2). 作用：是#include指令的增强版，将文件的内容在预编译的时候拷贝写指令的地方。
 3). 增强：同一个文件无论#import多少次，只会包含1次。
          如果#include指令要实现这个效果 就必须要配合条件编译指令来实现。
          而#import指令只需要直接包含就可以 其他什么都不用做。
 4). 简要原理：#import指令在包含文件的时候，底层会先判断这个文件是否被包含 如果被包含就会略过 否则才会包含。
 
 5. 框架
 1). 是一个功能集 苹果或第三方事先将一些程序在开发程序的时候经常用到的功能事先写好。把这些功能封装在1个1个的类或者函数之中。
     这些函数和类的集合就叫做框架。
     有点像C语言的函数库。
 2). Foundation框架。
     Foundation：基础 基本。这个框架中提供了一些最基础的功能 输入和输出。 一些数据类型。
     Foundation.h这个文件中包含了Foundation框架中的其他的所有的头文件。
     所以，我们只要包含Foundation.h 就相当于包含了Foundation框架中所有的头文件。
     那么Foundation框架中的所有的函数和类就可以直接使用。
 
 6. @autoreleasepool是自动释放池
    可以将代码写在自动释放池之中，或者干脆把这个自动释放池删除 不会有任何影响。
 
 7. NSLog函数。
    1). 作用：是printf函数的增强版，向控制台输出信息。
    2). 语法：NSLog(@"格式控制字符串", 变量列表);
        最简单的语法：NSLog(@"要输出的信息");
    3). 增强：
        a. 输出一些调试相关信息。
           2025-04-11 11:05:20.628 Day01-OC基础语法[784:210576] Hello, World!
           执行这段代码的时间。
           程序的名称。
           进程编号。
           线程编号。
           输出的信息。
        b. 会自动换行，在输出完信息之后 会自动换行。
        c. OC中其实新增了一些数据类型。NSLog函数不仅仅可以输出C数据类型变量的值，还可以输出OC新增的数据类型的变量的值。
    4). 用法和printf函数差不多。一样可以输出变量的值，并且占位符和用法都一样。
    5). 使用注意：
        a. NSLog函数的第一个参数前面必须要加一个'@'符号。
        b. 如果手贱在字符串的末尾加了1个'\n'代表换行，那么函数的自动换行功能就会失效。
 
 8. 字符串
    1). C语言的字符串的存储方式
        a. 使用字符数组存储
        b. 使用字符指针
    2). OC中设计了1个更为好用的用来存储字符串的一个类型。NSString
        NSString 类型的指针变量 专门用来存储OC字符串的地址。
    3). OC的字符串常量必须要使用1个前缀'@'符号。
        "jack" 这是一个 C语言的字符串。
       @"jack" 这是一个OC语言的字符串常量。
        NSString类型的指针变量，只能存储OC字符串的地址。
        NSString *str = @"jack";
    4). 总结
        a. 在OC中专门设计了1个NSString类型来存储字符串。
        b. 字符串分为C字符串和OC字符串。
           字符串如果没有'@'前缀 那么这个字符串常量就是1个C字符串。
           字符串如果有'@'前缀 那么这个字符串常量就是OC字符串。
           所以OC字符串常量的前面必须要加1个'@'符号。
        c. NSString类型的指针变量 只能存储OC字符串。
           NSString *str = @"jack";
    5). 注意：
        1). NSLog函数的第一个参数是1个OC字符串，所以NSLog函数的第一个实惨应该以'@'符号开头。
        2). 如果要使用NSLog函数输出OC字符串的值，那么使用占位符%@
 
 9. NS前缀。
    NextStep  --->  Cocoa  --->  Foundation框架之中。
 
 10. @符号
     1). 将C字符串转换为OC字符串。
         "jack"  @"jack"
     2). OC中的绝大部份的关键字都是以'@'符号开头。
 
 11. 注释
     和C语言的注释一摸一样，分为单行注释和多行注释。
 
 12. 函数的定义和调用。
     与C语言的函数的定义和调用是一样的。
 
 */
/*
 1. OC程序的编译、链接、执行。
    1). 在.m文件中写上符合OC语法规范的源代码。
    2). 使用编译器将源代码编译为目标文件。
        cc -c xx.m
        a. 预处理
        b. 检查语法，如果语法有问题，直接报错，不会进行下一步编译
        c. 编译
    3). 链接
        cc xx.o
        如果程序中使用到了框架中的函数或者类，那么在链接的时候，就必须要告诉编译器
        去那一个框架中找这个函数或者类。
        cc xx.o -framework 框架名称。
        cc main.o -framework Foundation
        程序中用到了那一个框架中的功能 那么就在这个地方告诉编译器。
    4). 链接成功以后 就会生成1个a.out可执行文件 执行就可以了。
 
 2. 我们点击运行按钮，所有的事情Xcode就帮我买自动做了。
 
 3. OC程序和C程序各个阶段的后缀名对比
    源文件         目标文件        可执行文件
C     .c            .o            .out
OC    .m            .o            .out
 
 */
/*
 1. OC中的数据类型
    1). OC中支持C语言中的所有数据类型。
        a. 基本数据类型
           int double float char
        b. 构造类型
           数组 结构体 枚举
        c. 指针类型
           int *p1;
        d. 空类型
           void
        e. typedef自定义类型。
    2). BOOL类型。
        1). 可以存储YES或者NO中的任意1个数据。
        2). 一般情况下BOOL类型的变量用来存储条件表达式的结果。如果条件表达式成立 那么结果就是YES
            如果条件表达式不成立 结果就是NO
        3). BOOL的本质。
            typedef signed char BOOL;
            实际上BOOL类型的变量 是一个有符号的char变量。
            #define YES ((BOOL)1)
            #define NO  ((BOOL)0)
            YES 实际上就是 1
            NO  实际上就是 0
    3). Boolean
        a. Boolean类型的变量可以存储true或者false
        b. 一般情况下Boolean类型的变量用来存储条件表达式的结果。如果条件表达式成立 那么结果就是true
           如果条件表达式不成立 结果就是false
        c. 本质
           typedef unsigned char Boolean;
           #define true 1
           #define false 0
    4). class 类型。类。
    5). id类型 万能指针。
    6). nil与NULL差不多。
    7). SEL方法选择器。
    8). block 代码段。
 */
/*
 1. 类和对象的关系：
    类是多个类似对象抽象总结而成，对象是类的实例化体现。
    类是对一群具体相同特征行为事物的统称，特点是抽象的不能直接去使用，
    对象是现实生活中具体的存在，特点是看的见摸得着，拿过来可以直接使用。
    面向对象的最大优点是，后期易于维护。
    面向过程是亲力亲为，面向对象是找人去做。
    对象的特点: 对象拥有类中定义的所有的成员。
    对象中的成员可以直接访问。
    同一个类可以创建N个对象，并且这N个对象毫无关系。
    在方法中可以直接访问属性，访问的就是当前对象的属性。
 
 2. 如何设计一个类：
    类的作用：用来描述一群具有相同特征和行为的事物的。
    设计类的三要素：
    -> 类的名字，你要描述的这类事物叫什么名字。
    -> 这类事物具有的相同的特征，这类事物拥有什么。
    -> 这类事物具有的共同的行为，这类事物会做什么。
 
 3. 如何定义类
    1). 定义类的语法：
        a. 位置，直接写在源文件之中，不要写在main函数之中。
        b. 语法：类的定义分为两个部分：
           -> 类的声明
           @interface 类名 : NSObject
           {
             这类事物具有的共同的特征，将他们定义为变量。
           }
           功能就是1个方法，将方法的声明写在这里。
           @end
           -> 类的实现
           @implementation 类名
           将方法的实现写在这里。
           @end
    2). 几点注意
        a. 类必须要有声明和实现
        b. 类名用你描述的事物的名称来命名就可以了。
           类名的每一个单词的首字母必须要以大写开头(大驼峰式命名法)。
        c. NSObject是什么意思？不用管，照写就可以了。
        d. 用来表示这类事物的共同的特征的变量必须要定义在'@'interface的大括号之中。
        e. 定义在大括号之中用来表示这类事物的共同的特征的变量，我们叫做：
           属性，成员变量，实例变量，字段...
        f. 为类定义属性的时候，属性的名称必须要以_开头 下划线开头。(规范)
    3). 语法是固定的：
        @interface 类名 : NSObject
        {
            这类事物具有的共同的特征定义为变量。
            数据类型 变量名1;
            数据类型 变量名2;
            ...
        }
        @end
        @implementation 类名
        @end
 
 4. 类是无法直接使用的，如果非要使用这个类的话，就必须要先找到这个类中的一个具体存在。
    再使用这个对象。
    如何创建一个类的对象呢？
    语法: 类名 *对象名 = [类名 new];
    e.g.: Person *p1 = [Person new];
          根据Person这个类的模版，创建了1个对象名字叫做p1。
          p1对象的特点：
          -> 可以直接使用。
          -> 类中定义的东西 这个对象中也有 不会多也不会少。
 5. 如何使用对象
    如何访问对象的属性：
    1). 默认情况下，对象的属性是不允许被外界直接访问的。
        如果允许对象的属性可以被外界访问，那么就在声明属性的时候加一个'@'public关键字。
    2). 访问对象的属性的方式
        对象名->属性名 = 值;
        对象名->属性名;
        (*对象名).属性名;
        平时使用的时候，使用->
 
 6. 方法的声明实现和调用
    一类事物不仅具有相同的特征还具有相同的行为。
    行为就是一个功能，C语言中使用函数来表示一个功能。
    OC的类具有的行为，我们使用方法来表示。
    方法和函数都表示一个功能。
    -> 方法的声明
    @interface 类名 : NSObject
    {
        属性 属性表示类的特征。
    }
    方法的声明; 方法表示类的功能(行为)。
    @end
    -> 方法的实现
    @implementaction 类名
    方法的实现;
    @end
 
 7. 无参数的方法。
    1). 声明
        a. 位置：在'@'interface的大括号的外面。
        b. 语法：
           - (返回值类型)方法名称;
           - (void)run;
           表示声明了1个无返回值并且无参数的方法，方法名字叫做run
    2). 实现
        a. 位置：在'@'implementation之中实现
        b. 实现的语法:
           将方法的声明拷贝到'@'implementation之中 去掉分号 追加大括号一对 将方法实现的代码写在大括号之中。
    3). 调用
        a. 方法是无法直接调用的，因为类是不能直接使用的，必须要先创建对象。
           那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了。
        b. 调用对象的方法。
           [对象名 方法名];
 
 8. 带1个参数的方法。
    1). 声明
        a. 位置：在'@'interface的大括号的外面。
        b. 语法：
           - (返回值类型)方法名称:(参数类型)形参名称;
           - (void)eat:(NSString *)foodName;
           定义了1个方法，这个方法没有返回值。
           这个方法的名字叫做eat:
           这个方法有1个参数，类型是NSString *类型的 参数的名字叫做foodName
    2). 实现
        a. 位置: 在'@'implementation之中实现
        b. 语法: 将方法的声明拷贝到'@'implementation之中 去掉分号 追加大括号一对 将方法实现的代码写在大括号之中。
    3). 调用
        a. 方法是无法直接调用的，因为类是不能直接使用的，必须要先创建对象。
           那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了。
        b. 调用语法:
           [对象名 方法名:实参];
 
    方法头中的数据类型都要用1个小括号括起来。
    - (返回值类型)方法名称:(参数类型)参数名称;
 
 9. 带多个参数的方法。
    1). 声明
        a. 位置：在'@'interface的大括号的外面。
        b. 语法：
           - (返回值类型)方法名称:(参数类型)形参名称1 :(参数类型)形参名称2 :(参数类型)形参名称3;
           - (int)sum:(int)num1 :(int)num2;
           表示声明了1个方法，这个方法的返回值类型是int类型的。
           方法的名称叫做 sum: :
           有2个参数，参数类型都是int类型 参数名称叫做num1 num2
    2). 实现
        a. 位置: 在'@'implementation之中实现
        b. 实现的语法: 将方法的声明拷贝到'@'implementation之中 去掉分号 追加大括号一对 将方法实现的代码写在大括号之中。
    3). 调用
        a. 方法是无法直接调用的，因为类是不能直接使用的，必须要先创建对象。
           那么这个对象中就有类中的属性和方法了 就可以调用对象的方法了。
        b. 调用带多个参数的语法:
           [对象名 方法名:实参1 :实参2 :实参3];
 
 10. 带参数的方法声明的规范：
     1). 如果方法只有1个参数，要求最好这个方法的名字叫做 xxxWith:
         xxxWithXxx: eatWith: eatWithFood:
         这样写的话，那么调用方法的时候看起来就像是1条完整的语句，提高了我们代码的阅读性。
         遵守的规范: 就是让我们的方法调用的时候看起来像1条完整的语句。
     2). 如果方法有多个参数 建议这个方法名称:
         方法名With:(参数类型)参数名称 and:(参数类型)参数名称 and:(参数类型)参数名称;
         - (int)sumWith:(int)num1 and:(int)num2;
         sunWith: and:
         更详细的写法
         方法名With参数1:(参数类型)参数名称 and参数2:(参数类型)参数名称 and参数3:(参数类型)参数名称;
  */
/*
 其他使用注意：
 1. 同一个类可以创建无数个对象。
 2. 同一个类的多个对象之间毫无关系。
    虽然他们拥有相同的属性和方法
    属性的值是不会相互影响的
 3. 在方法的实现中，可以直接访问属性
    在方法中访问的属性是谁的属性呢？
    这个方法是通过那1个对象来调用的，那么方法中的直接访问的属性就是那1个对象的。
 */

 1. 内存中的五大区域
    栈             存储局部变量
    堆             程序员手动申请的字节空间 malloc calloc realloc 函数
    BSS段          存储未被初始化的全局变量 静态变量
    数据段(常量区)   存储已被初始化的全局 静态变量 常量数据
    代码段          存储代码 存储程序的代码
 
 2. 类加载
    1). 在创建对象的时候 肯定是需要访问类的。
    2). 声明1个类的指针变量也会访问类的。
    在程序运行期间 当某个类第一次被访问到的时候，会将这个类存储到内存中的代码段区域，这个鬼才叫做类加载。
    只有类在第一次被访问的时候，才会做类加载。
    一旦类被加载到代码段以后，直到程序结束的时候，才会被释放。
 
 3. 对象在内存中究竟是如何存储的.
    假设下面这个写在函数之中.(局部变量)
    Person *p1 = [Person new];
    1). Person *p1; 会在栈内存中申请1块空间. 在栈内存中声明1个Person类型的指针变量p1.
                    p1是1个指针变量, 那么只能存储地址.
    2). [Person new]; 真正在内存中创建对象的其实是这句代码.
                      new做的事情
                      a. 在堆内存中申请1块合适大小的空间
                      b. 在这个空间中根据类的模版创建对象.
                         类模版中定义了什么属性.就把这些属性依次的声明在对象之中.
                         对象中还有另外一个属性, 叫做isa 是一个指针, 指向对象所属的类在代码段中的地址.
                      c. 初始化对象的属性
                         如果属性的类型是基本数据类型 那么就赋值为0
                         如果属性的类型是C语言的指针类型 那么就赋值为NULL
                         如果属性的类型是OC的类指针类型 那么就赋值为nil
                      d. 返回对象的地址.
    3). 注意
        a. 对象中只有属性, 而没有方法. 自己类的属性外加一个isa指针指向代码段中的类.
        b. 如何访问对象的属性
           指针名->属性名;
           根据指针 找到指针指向的对象 再找到对象中的属性来访问.
        c. 如何调用方法.
           [指针名 方法名];
           先根据指针名找到对象, 对象发现要调用方法, 再根据对象的isa指针找到类.
           然后调用类里的方法.
 
 4. 为什么不把方法存储在对象之中?
    因为每一个对象的方法的代码实现都是一模一样的, 没有必要为每一个对象都保持1个方法, 这样的话就太浪费空间了.
    既然都一样 那么就只保存1份.
 
 5. 对象的属性的默认值.
    如果我们创建1个对象, 没有为对象的属性赋值, 那么这个对象的属性是有值的.
    如果属性的类型是基本数据类型 默认值是0
    如果属性的类型是C指针类型 那么默认值是NULL
    如果属性的类型是OC指针类型 那么默认值是nil
  */
/*
 nil与NULL
 1. NULL
    只能作为指针变量的值, 如果1个指针变量的值是NULL值. 代表这个指针不指向内存中的任何1块空间.
    NULL其实等价于0 NULL其实是1个宏. 就是0
 2. nil
    只能作为指针变量的值. 代表这个指针变量不指向内存中的任何空间.
    nil其实也等价于0 也是1个宏, 就是0.
    所以, NULL和nil其实是一样的.
 3. 使用建议.
    虽然使用NULL的地方可以使用nil 使用nil的地方可以使用NULL 但是不建议大家去随便使用.
    C指针用NULL
        int *p1 = NULL; p1指针不指向内存中的任何1块空间.
    OC的类指针用nil
        Preson *p1 = nil; p1指针不执行任何对象.
 4. 如果1个类指针的值为nil 代表这个指针不指向任何对象.
    Person *p1 = nil;
    那么这个时候 如果通过p1指针去访问p1指针指向的对象的属性 这个时候会运行报错.
    那么这个时候 如果通过p1指针去调用对象的方法 运行不会报错 但是方法不会执行 没有任何反应.
 */
/*
 多个指针指向同1个对象
 1. 同类型的指针变量之间是可以相互赋值的.
    Person *p1 = [Person new];
    Person *p2 = p1; 这是完全没有问题的, p1和p2的类型都是Person指针类型的.
    代表将p1点值赋值给p2 而p1的值是对象的地址 所以就把对象的地址赋值给了p2
    所以p1和p2指向了同1个对象.
    无论通过p1还是p2去修改对象, 修改的都是同1个对象.
 2. 目前为止, 只要你看到new 就说明新创建了1个对象.
 */
/*
 分组导航标记:
 1). #pragma mark 分组名
     就会在导航条对应的位置显示1个标题.
 2). #pragma mark -
     就会在导航条对应的位置显示1条水平分隔线.
 3). #pragma mark - 分组名
     就会在导航条对应的位置先产生1条水平分隔线.再显示标题.
 */
/*
 方法函数
 1. 我们之前在C中学习的函数, 就叫做函数.
    void test(){}
 2. 在OC类中写的方法, 就叫做方法
    -(void)sayHi;
 3. 相同点:
    都是用来封装1段代码的, 将1段代码封装在其中,表示1个相对独立的功能
    函数或者方法只要被调用, 那么封装在其中的代码就会被自动执行.
 4. 不同点:
    1). 语法不同.
        函数声明的语法:
        返回值类型 函数名(参数列表);
        方法的语法:
        - (返回值类型) 方法名:(参数类型) 参数名;
    2). 定义的位置不一样.
        OC方法的声明只能写在'@'interface的大括号的外面, 实现只能写在'@'implementation之中.
        函数除了在函数的内部和'@'interface的大括号之中 其他的地方都可以写.
        就算把函数写在类中 这个函数仍然不属于类 所以创建的对象中也没有这个函数.
        注意: 函数不要写到类中, 虽然这样是可以的, 但是你千万不要这么做, 因为这么做是极度的不规范的.
    3). 调用的方式也不一样.
        函数可以直接调用.
        但是 方法必须要先创建对象 通过对象来调用.
    4). 方法是属于类的, 有1个family, 有个归属感.
        而函数是一个孤魂野鬼, 就是1个独立的.
 */
/*
 1. 最容易犯错
    1). @interface是类的声明. @implementation是类的实现 他们之间不能相互嵌套
    2). 类必须要先声明然后再实现
    3). 类的声明和实现必须都要有 就算没有方法 类的实现也必不可少的.
    4). 类的声明必须要放在使用类的前面.
        实现可以放在使用类的后面
    5). 声明类的时候 类的声明和实现必须要同时存在.
        特殊情况下可以只有实现 没有声明.
        虽然可以这样, 但是我们平时在写类的时候千万不要这么写 因为这么写是极度不规范的.
    6). 属性名一定要以下划线开头 这是规范 否则后面的知识点你就对不上号.
        类名 每一个单词的首字母大写.
    7). 属性不允许声明的时候初始化
        在为类写1个属性的时候 不允许在声明属性的时候为属性赋值.
    8). OC方法必须要创建对象通过对象名来调用
    9). 方法只有声明 没有实现
        a. 如果方法只有声明 没有实现 编译器会给1个警告 不会报错.
        b. 如果指针指向的对象 有方法的声明 而没有方法的实现 那么这个时候通过指针来调用这个方法
           在运行的时候 就会报错.
           unrecognized selector sent to instance 0x100420510
           只有你看到了这个错误, 说明要么对象中根本就没有这个方法, 要么只有方法的声明而没有方法的实现.
 */
/*
 多文件开发
 1. 所有的类都写在main.m这个源文件之中的.
    后果: 后期的维护就非常的不方便, 也不利于团队开发.
 2. 推荐的方式
    把1个类写在1歌模块之中, 而1个模块至少包含两个文件.
    .h 头文件
       写类的声明 因为要用到Foundation框架中的类 NSObject 所以在这个头文件中要引入Foundation框架的头文件.
       然后将类的声明的部分写在.h文件中
    .m 实现文件
       先引入模块的头文件 这样才会有类的声明
       再写上类的实现.
    如果要用到类. 只需要引入这个类模块的头文件就可以直接使用了.
 3. 添加类模块的更简洁的方式
    NewFile Cocoa Class 自动生成模块文件 .h .m
    自动的将类的声明和实现写好.
    填写的名称是决定模块文件的名称. 类名是可以自己再改的,
    但是建议模块的文件名和模块中的类名保持一致, 这样方便代码的管理
 4. 当我们要使用这个类的时候, 需要先将这个类的头文件先引进来, 才可以使用.
 */
/*
 1. 对象和方法.
    对象作为方法的参数, 对象作为方法的返回值.
 2. 类的本质是我们自定义的1歌数据类型, 因为对象在内存中的大小是由我们决定的.
    多写几个属性 对象就大一些 少写几个属性 对象占用的空间就小一些.
    什么是数据类型: 是在内存中开辟空间的1个模版.
 3. 既然类是1个数据类型, 那么类就可以作为方法的参数.
    - (void)test:(Dog *)dog;
    这个是完全没有问题的.
 
 ----语法注意----
 1. 当对象作为方法的参数的时候, 参数应该怎么写 参数类型是指针,
    - (void)test:(Dog *)dog;
 2. 调用方法的时候 如果方法的参数是1个对象.
    那么给实参的时候, 实参要求也必须是1个符合要求的对象. 否则就会出问题.
 3. 当对象作为方法的参数传递的时候, 是地址传递.
    所以 在方法内部通过形参去修改形参指向的对象的时候 会影响实参变量指向的对象的值.
 ----
 对象也可以作为方法的返回值.
 1. 什么时候方法的返回值是1个对象呢?
    当方法执行完毕之后, 如果有1个对象方法的内部不知道如何处理, 并且这个对象是调用者翘首以盼的.
    那么这个时候我们就应该将这个对象返回.
 2. 如果方法的返回值是1个对象, 那么返回值类型应该写 类指针.
 */
/*
 对象作为类的属性
 1. 1个Target中的类无法直接在另外1个Target中访问.
    show in finder -> 拖拽模块类文件到项目目录下, 勾选Copy items if needed和Create groups即可完成类文件拷贝
 2. 属性的本质是变量.
    在创建对象的时候, 对象中的属性是按照类模版中的规定挨个挨个的创建出来的.
    类模板中属性是什么类型,那么对象中的属性就是什么类型.
    如果对象的属性是另外1个类的对象, 这个属性仅仅是1个指针变量而已, 并没有对象产生.
    这个时候 还要为这个属性赋值1个对象的地址 才可以正常使用.
 3. A类可以作为B类的属性, 代表B拥有A.
    属性仅仅是1个变量而已, 是一个指针变量而已, 默认值是nil, 并没有创建对象,
    这个时候如果你要正常使用的话, 还要为B对象的A属性赋值1个对象.
 4. 枚举或者结构体定义在什么地方.
    如果只是1个类要用, 那么就定义在这个类的头文件中.
    如果多个类要用, 那么就定义在1个单独的头文件中, 谁要用 谁就去引就可以了
 5. 如果要在方法中调用当前对象的另外1个方法.
    [self 方法名];
    self代表当前对象.
 */

 对象与方法
 1). 类的本质是我们自定义的1歌数据类型.
 2). 类既然是1个数据类型, 那么类 类型的 指针变量完全可以当作方法的参数或者返回值
 3). 当类作为方法的参数的时候, 在方法执行的时候 参数只是1个指针而已 没有创建对象.
     为参数传值以后. 形参指针和实参指针指向了同1个对象.
     在方法的内部通过形参指针去访问对象 访问的就是实参指针指向的对象.
 4). 对象作为方法的返回值.
     方法的作用就是创建1个对象 把这个对象的地址返回给调用者.
 5). 本类对象作为本类方法的参数
 */
/*
 1. 什么是错误?
    一般情况下, 错误指的是我们写的源代码不符合语法规范, 然后编译报错.
    后果: 程序无法编译.
    解决: 将不符合语法规范的代码改为符合语法规范的代码不就可以了吗.
 2. 什么是Bug?
    程序可以编译 链接 执行. 程序执行的结果并不是我们所预想的那样.
    解决: 通过调试寻找发生Bug的原因.
 3. 什么是异常?
    程序可以编译 链接 执行.
    当程序在执行的时候 处于某种特定条件下 程序的执行就会终止.
    异常的后果: 程序会立即崩溃. 程序立即终止运行. 并且后面的代码不会执行了
 4. 如何处理异常.
    1). 目的: 为了让程序在执行的时候如果发生了异常而不崩溃 而是继续往下执行.
    2). 语法:
        @try{}
        @catch(NSException *ex){}
        将有可能发生异常的代码放在@try中.
        当@try中的代码在执行的时候. 如果发生了异常. 不会崩溃, 而是会立即跳转到@catch中去执行里面的代码.
        当@catch的代码执行完毕之后 结束@try...@catch往下执行.
        如果@try中的代码在执行的时候 没有发生异常. 就会略过@catch往下执行.
    3). 当@try中的代码在执行的时候发生了异常. @try块发生异常的后面的代码不会执行. 而是立即转到@catch
 5. @catch中的代码只有在@try的代码发生异常的时候才会执行.
    所以, @catch中我们一般情况下写处理异常的代码.
    发生这个异常以后 要做什么事情.
 6. @catch的参数NSException *ex 通过%@打印出ex指向的对象的值.
    可以拿到发生异常的原因
 7. @try...@catch后面还可以跟1个@finally
    @finally中的代码. 无论@try中是否发生了异常都会被执行.
 8. @try...@catch并不是万能的. 不是所有的运行时错误都可以处理的.
    C语言的异常是无法处理的.
    在实际的开发过程中 使用@try用的相对比较少的.
    避免异常我们最常用的方式还是逻辑判断.
 */
/*
 1. OC中的方法分为两种.
    1). 对象方法/实例方法:
        我们之前学习的方法 就叫做对象方法. 如果想要调用对象方法就必须要先创建对象. 通过对象名来调用.
    2). 类方法.
        类方法的调用不依赖于对象. 如果要调用类方法 不需要去创建对象. 而是直接通过类名来调用.
 2. 声明.
    1). 对象方法的声明:
        对象方法声明使用 - 号
        - (返回值类型)方法名;
    2). 类方法的声明:
        类方法声明使用 + 号.
        + (返回值类型)方法名;
        和对象方法的声明实现除了+和- 其他的都是一样的.
 3. 调用.
    1). 对象方法: 先创建对象 再通过对象名来调用.
    2). 类方法: 不需要通过对象名来调用 所以如果要调用类方法不需要创建对象.
        而是直接使用类名来调用
        [类名 类方法名];
 4. 分析一下 类方法和对象方法的调用过程.
    类方法的特点:
    1). 节约空间: 因为调用类方法不需要创建对象. 这样就节约了空间.
    2). 提高效率: 因为调用类方法不需要拐弯 直接找到类 直接执行类中的类方法.
 5. 在类方法中不能直接访问属性.
    1). 属性是在对象创建的时候. 跟随着对象一起创建在对象之中.
    2). 类第一次被访问的时候, 会做类加载. 是把类的代码存储在代码段
    因为属性只有在对象创建的时候才会创建在对象之中.
    而类方法在执行的时候. 有可能还没有对象. 对象都没有 你访问个毛的属性.
    虽然不能直接访问属性, 但是我们可以在类方法中创建1个对象 访问这个对象的属性.
 6. 在类方法中也不能通过self直接调用当前类的其他的对象方法
    因为对象方法只能通过对象来调用 而这个时候没有对象.
 7. 在对象方法中可以直接调用类方法.
 8. 什么时候我们可以将方法定义为类方法呢?
    如果方法不需要直接访问属性 也不需要直接调用其他的对象方法.
    那么我们就可以将这个方法定义为类方法
    这样就 节约空间 提高效率.
 9. 关于类方法的规范.
    1). 如果我们写1个类, 那么就要求为这个类提供1个和类同名的类方法.
        这个方法创建1个最纯洁的对象返回.
        因为苹果和第三方写的类都遵守这个规范.
    2). 如果你希望创建的对象的属性的值由调用者指定, 那么就为这个类方法带参数.
        类名WithXXX: ...
 */
/*
 1. NSString是1个数据类型. 用来保存OC字符串的.
 2. 其实NSString是Foundation框架中的1个类.
    作用: 存储OC字符串的
    所以OC中的字符串本质上是用NSString对象来存储的.
 3. 其实完整的标准的创建NSSting对象的方式
    NSString *str0 = [NSString new];
    NSString *str1 = [NSString string];
    这种方式创建的字符串是空字符串 @""
    但是 NSString是我们最常用的1个对象 所以OC使用了1种更为简单的方式来创建字符串对象.
    直接使用@来表示1个OC字符串.
    @"jack" 这个其实本质上是1个NSString对象.
    NSString *str = @"jack";
    @"jack" 是1个NSString对象 str的值是这个对象的地址.
    %p 打印的是指针变量的值
    %@ 打印的是指针变量指向的对象.
    NSString *str2 = [NSString stringWithFormat:@"jack"];
 4. NSString最常用的类方法.
    1). + (instancetype)stringWithUTF8String:(const char *)nullTerminatedCString;
        instanceType 作为返回值 代表返回的是当前这个类的对象.
        作用: 将C语言的字符串转换为OC字符串对象.
        NSString *str = [NSString stringWithUTF8String:"jack"];
    2). + (instancetype)stringWithFormat:(NSString *)format, ... 使用频率100分.
        作用: 拼接1个字符串对象. 使用变量或者其他数据拼接成OC字符串.
        int age = 19;
        NSString *name = @"小明";
        NSString *str = [NSString stringWithFrom:@"大家好, 我叫%@, 我今年%d岁", name, age];
        NSLog(str);
 5. 最常用的对象方法:
    1). length方法 返回值为NSUInteger 其实就是unsigned long
        得到字符串的字符的个数 可以处理中文.
        NSString *str = @"jack";
        NSUInteger len = [str length];
        NSLog(@"%lu", len);
    2). 得到字符串中指定下标的字符.
        - (unichar)characterAtIndex:(NSUInteger)index;
        返回值是unichar 其实就是unsinged short 占据2个字节.
        如果要输出unichar变量的值使用%C, 大写的C
        %c只会读取变量当中第一个字节中的数据
        %d只会读取变量当中前面4个字节的数据
        %C只会读取变量当中前面2个字节的数据
        NSLog(@"%C", [str characterAtIndex:2]);
    3). 判断两个字符串的内容是否相同.
        a. 判断两个字符串的内容是否相同 不要用 == 去判断 因为这样有可能会出问题.
        b. 判断相等的方式.
           -(BOOL)isEqualToString:(NSString *)aString;
           所以判断两个字符串是否相等 应该使用这个方法去判断 才会得到正确的结果.
           [str1 isEqualToString:str2];
    4). 比较字符串的大小.
        -(NSComparisonResult)compare:(NSString *)string;
        完全可以使用int类接收结果. 因为返回值是1个枚举.
        返回值如果是 -1 说明小于
                    0 等于
                    1 大于
        int result = [str1 compare:str2];
 */
/*
 匿名对象
 1. 我们之前创建对象的做法.
    Person *p1 = [Person new];
    让1个指针指向1个对象, 这个指针就叫做这个对象的名字.
 2. 匿名对象.
    没有名字的对象, 如果我们创建1个对象, 没有用1个指针存储这个对象的地址.
    也就是没有任何指针指向这个对象 那么这个对象就叫做匿名对象.
 3. 如何去使用1个匿名对象呢?
    因为new实际上1个类方法. 这个方法做的事情创建对象(4个步骤). 返回值是创建的对象的地址.
    [Person new] 这句代码的结果实际上就是创建的那个对象的指针, 那我们可以直接使用.
    [Person new]->_name = @"jack";
    [[Person new] sayHi];
 4. 注意点:
    1). 匿名对象只能使用1次.
    2). 每次创建匿名对象都是不同的对象.
 5. 有什么用?
    1). 如果某个对象的成员只会被我们使用1次, 用完之后这个对象再也不需要了 那么就可以使用匿名对象.
    2). 如果方法的参数是1个对象, 而调用者为这个参数赋值的对象 就是专门来给这个方法传递的
        并且这个对象调用者不会使用 那么这个时候就可以直接为方法传递1个匿名对象.
 */
/*
 1. 面向对象的三大特征是什么?
    封装
        函数就是1个封装的体现
        类就是更高级别的封装. 类将数据和行为封装为类1个整体.
        好处:
        -> 屏蔽内部的实现. 外界不需要知道内部是如何实现的 只需要知道这个对象有什么用.
        -> 方便操作.
        -> 后期的维护十分的便利.
    继承
    多态
 属性的封装
 2. 存在的问题.
    就是为对象的属性赋值的时候 语法上其实只要数据的类型是属性的类型就是可以的.
    但是情理上这么做是不合的.
    就像Person对象有1个int类型的属性_age 表示1个人的年龄.
    为这个对象的_age属性赋值的时候 其实只要是int类型的数据 语法上都是完全可以的.
    但是1个人的年龄 正常情况下是在 0-200之间的.
    解决的问题:
    在为对象的属性赋值的时候, 我希望将这个数据做1个逻辑验证.
    如果为属性赋的值在这个逻辑范围之内 那么我们就吧这个值赋值给属性, 否则我们就做默认处理.
    就像我们希望为Person对象的_age属性赋值的时候, 要判断一下为_age属性赋的值是不是在0-200之内.
    否则我们就做默认处理.
 3. 如何实现这个需求.
    1). 将属性的@public去掉, 因为一旦写上@public就意味着外界可以直接访问对象的这个属性.
        外界一旦可以直接访问这个属性 那么外界就可以任意的为这个属性赋值 这个时候你拦都拦不住.
        去掉@public 外界就无法直接访问这个属性 也就无法赋值了.
    2). 为类提供1个方法, 这个方法专门为这个属性赋值, 这个方法我们叫做setter
        a. 这个方法一定是1个对象方法, 因为这个方法要为属性赋值.
        b. 这个方法没有返回值. 因为这个方法做的事情 仅仅是为类属性赋值就可以了.
        c. 这个方法的名称必须以set开头. 跟上去掉下划线首字母大写的属性名.
        d. 这个方法一定是有参数的. 参数的类型和属性的类型一致. 参数的名称和属性的名称一致(去掉下划线)
        e. 在方法的实现中, 判断传入的数据是否符合逻辑. 如果符合逻辑则赋值 否则做默认处理.
        f. 外界想要为对象的属性赋值 那么就调用这个对象的setter方法 将要赋值的数据传入给这个方法.
           方法会对这个数据进行验证 如果符合验证 就会把数据赋值给属性 否则就会做默认处理.
    3). 这么一写, 我们确实可以在为对象的属性赋值的时候做1个逻辑验证了.
        但是问题就是 在外界无法取出属性的值了.
        那么再写1个方法, 专门用来返回属性的值. 这个方法我们叫做getter方法.
        a. 这个方法一定是1个对象方法 因为这个方法做的事情是拿到属性的值返回.
        b. 这个方法肯定有返回值 返回值的类型和属性的类型一致.
        c. 这个方法的名称直接就是属性的名称(去掉下划线的)
        d. 这个方法没有参数
        e. 这个方法的实现是直接将属性的值返回.
        f. 这个时候 如果外界希望得到属性的值. 那么就只需要调用这个getter方法就可以了.
 4. 注意:
    1). 属性去掉@public修饰符
    2). 要分清楚参数和属性, 判断参数的值是否符合逻辑 将参数赋值给属性
    3). getter setter 方法名要符合规范
 5. 什么时候需要为属性封装getter和setter?
    1). 只有属性需要被外界访问, 就要为这个属性封装setter和getter.
        哪怕在赋值或者取值的时候没有任何逻辑验证.
    2). 如何属性只在类的内部访问. 那么就不需要为其封装getter setter
 6. 只读封装与只写封装.
    只读封装: 为属性封装的时候 只提供getter 不提供setter
    只写封装: 为属性封装的时候 只提供setter 不提供getter
 */
/*
 对象之间的关系:
 1. 组合关系:
    1个类是由其他的几个类联合起来组合而成, 那么他们之间的关系就叫做组合关系.
    电脑是由CPU类、内存类、主板类组合而成, 他们之间的关系是组合关系.
 2. 依赖关系
    1个对象的方法的参数是另外1个对象. 那么我们就说他们的关系是依赖关系.
    比如, B类是A类方法的参数, 我们就说A类依赖于B类.
    打电话的例子.
    人类:
    callWithPhone:(Phone *)phone;
    我们就说人类依赖于电话类. 人要打电话, 就必须要有电话对象.
    电话类:
 
    耦合度: 当修改1个对象的时候 对另外1个对象的影响程度.
    1个类修改了 另外1个类就玩完.
    低耦合: 当修改1个对象的时候 对另外1个对象的影响较小甚至没有影响.
    高内聚: 1个对象仅仅做自己相关的事情.
    单一职责原则. 1个类只做自己的事情. 别人的事情给别人做.
 3. 关联关系
    1个类作为另外1个类的属性, 但是他们不是组合关系 而是1个拥有的关系.
    拥有关系. 关联关系.
    人拥有一条狗(狗类), 人拥有一台电脑(电脑类).
 总结:
    类是由其他类组合而成为组合关系, 例:电脑类属性有CPU类、内存类、主板类.
    类方法的参数为1个对象为依赖关系, 例:人用手机打电话, 人类依赖手机类, 没有手机类无法打电话.
    类拥有某个类为关联关系, 例:人类拥有狗类, 人类拥有电脑类.
    
    在依赖关系中, 当修改1个对象的时候对另外1个对象的影响程度被称为耦合度,
    影响大->高耦合, 影响小->低耦合, 降低或解除类与类之间的影响被称为解耦.
    内聚为类内部关联性的一种体现: 关联松散为低内聚, 职责单一为高内聚
    开发要做到 低耦合 高内聚
 */


 类方法注意事项:
    1). 在类方法中不能直接访问属性. 也不能使用self直接调用其他的对象方法.
    2). 在类方法的内部创建1个对象 访问这个对象的成员
    3). 在对象方法中可以直接使用类名来调用类方法.
 NSString常用方法:
    1). 把C字符串转换为OC字符串 [NSString stringWithUTF8String:"123"];
    2). 拼接的方式拼接字符串    [NSString stringWithFormat:@"%@-%d",@"jack",123];
    3). 长度                 [str length];
    4). 相等                 [str1 isEqualToString:str2];
    5). 比较                 [str1 compare:str2];
    6). 字符串下标            [str characterAtIndex:n]
 */
/*
 1. C语言中的static
    a. 修饰局部变量
    b. 修饰全局变量.
    c. 修饰函数.
 2. OC中的static关键字.
    a. static不能修饰属性, 也不能修饰方法.
    b. static可以修饰方法中的局部变量.
       如果方法中的局部变量被static修饰, 那么这个变量就会被变成静态变量.
       存储在常量区 当方法执行完毕之后 不会回收 下次再执行这个方法的时候 直接使用 而不会再声明了.
    如果在创建1个对象的时候, 希望内部属性id或者number自增, 那么需要使用static关键字修饰变量, 赋值给属性.
 3. 如果方法的返回值是当前类的对象, 那么方法的返回值就写instancetype
 */
/*
 1. 在方法的内部可以定义1个和属性名相同的局部变量.
    这个时候 如果在方法中访问这个同名变量, 访问的是局部变量.
    问题1: 如果这个时候就是要访问那个同名的属性, 怎么办?
    问题2: 在1个对象方法中要调用当前对象的另外1个对象方法怎么办?
 2. self: 自己的.
    和java、c#中的this关键字有1点点像.
    可以在对象方法和类方法中使用.
    self是1个指针, 在对象方法中self指向当前对象, 在类方法中self指向当前类.
 3. self用在对象方法中.
    1). self在对象方法中 指向当前对象.
        当前对象: 谁调用方法谁就是当前对象.
    2). 在对象方法中, self指向当前对象, 然后这有什么用?
        a. 可以使用self显示的访问当前对象的属性.
           self->属性. 代表访问的是当前对象的这个属性.
        b. 可以使用self来调用当前对象的其他的对象方法.
    3). 对象方法中使用self的场景.
        a. 必须使用self的场景.
           -> 如果在方法在存在和属性同名的局部变量,
              你如果想要访问同名的局部变量, 直接写就可以了.
              你如果想要访问当前对象的同名属性 必须使用self
           -> 在对象方法中, 如果要调用当前对象的其他的对象方法 必须使用self.
        b. 选用self的场景.
           在方法中不存在和属性同名的局部变量 如果这个时候想要访问当前对象的属性
           用不用self效果都是一样的. 都是访问的当前对象的属性.
    属性要求以下划线开头 局部变量不要求以下划线开头 按照这个规范来 实际上是不会重名的.
 
 4. 把self用在类方法中
    1). 类加载, 当类第一次被访问的时候 会将类的代码存储在代码区.
               代码区中用来存储类的空间也有1个地址.
    2). 在类方法中 self也是1个指针. 指向当前这个类在代码段中的地址.
        self 在类方法中 就相当于是当前这个类.
    3). 总结1下取到类在代码段中的地址的方式.
        a. 调式查看对象的isa指针的值.
        b. 在类方法中查看self的值.
        c. 调用对象的对象方法class 就会返回这个对象所属的类在代码段中的地址.
        d. 调用类的方法class 就会返回这个类在代码段中的地址.
    4). 有什么用?
        可以在类方法中使用self来显示的调用本类的其他的类方法.
        使用建议, 如果要在当前类方法中调用本类的其他的类方法 虽然可以直接使用类名 但是建议使用self
 
 5. 对象方法可以声明多次, 但事实只会认为有1次.
    对象方法如果有多次声明只能实现1次 否则就会报错.
    对象方法之间不能重名的.
    类方法之间也是不可以重名的.
    但是 对象方法和类方法是可以重名的.
    通过类名来调用 调用的就是类方法.
    通过对象名来调 调用的就是对象方法.
 
 6. 注意:
    1). 在对象方法中, self代表当前对象.
        多以可以通过self访问当前对象的成员.
        在对象方法中 不能使用self调用本类的类方法.
    2). 在类方法中, self代表当前这个类.
        所以, 可以通过self调用当前类的其他的类方法.
        在类方法中 不能使用self访问对象的成员, 不能区直接访问属性和调用对象方法.
 */
/*
 1. 遇到的问题: 多个类具有相同的成员.
    a. 复制 粘贴.
       -> 代码冗余.
       -> 后期的回沪不方便.
    b. 使用继承.
 2. 继承的目的: 子类想拥有父类中所有的成员, 但是不想自己去定义, 而是想凭空拥有.
 3. 继承的语法: 如何让1个类继承另外1个类, 因为想拥有父类中所有的成员.
    语法:
    @interface 类名 : 父类的名称
    @end
 4. 继承的效果:
    子类一旦从父类去继承, 那么子类中拥有了父类中的所有的成员. 不用自己定义.
 5. 几个术语:
    @interface A : B
    1). A类从B类继承. A类是B类的子类, B类是A的父类.
    2). A类从B类派生. A类是B类的派生类, B类是A的基类.
 
    子类一旦从父类继承, 就意味着子类拥有了父类的所有的成员 而不用自己去定义.
 */
/*
 1. 在新创建类模块的时候 指定父类, Xcode就会自动的帮助你完成一系列的事情. (头文件导入, 继承类名)
 2. 继承是类在继承. 而不是对象在继承.
    子类从父类继承. 子类中就拥有了父类中定义的所有的成员. 只是类继承.
    我们创建对象. 对象与对象之间是毫无关系的.
 3. 什么时候应该使用继承?
    如果发现另外1个类中的成员我也想有, 那么这个时候就可以使用继承.
    千万不要为了继承而去继承, 不要为了仅仅是得到某个类的成员你就不顾一切的去乱继承.
    满足继承的关系 is a
    凡是满足is a关系的类 就可以拥有继承的关系.
    当A类是1个B类的时候 那么A类就可以从B类继承
 4. 总结:
    1). 子类从父类继承, 就意味着子类拥有父类的所有的成员 包括属性和方法.
    2). 继承是类在继承. 而不是对象在继承.
        子类对象中拥有父类对象中的同样的成员.
    3). 满足继承的关系 is a 只有瞒住is a关系的类才可以拥有继承关系.
 5. 如果有1个成员不是所有的子类都拥有的, 那么这个成员就不应该定义在父类之中.
    因为一旦定义在父类之中, 那么所有的子类全都有了.
    父类中只定义所有子类都拥有的. 只要不是所有的子类都拥有的, 那么就不应该定义在父类之中.
 */
/*
 继承的特点:
 1. 单根性: 1个类只能有1个父类, 不能有多个父类.
 2. 传递性: A类从B类继承, B类从C类继承, 那么A类就同事拥有B, C类的成员.
 3. NSObject类
    是Foundation框架中的类, 在这个类中有1个类方法new
    这个方法是用来创建对象的. 方法的返回值是创建的这个对象的指针.
    也就是说, 如果要创建类的对象, 就必须要调用这个new方法.
    如果我们想要让我们的类具备创建对象的能力, 就必须要让我们的类直接的或者间接的从NSObject类继承.
    所以要求: 我们写的类必须直接的或者间接的要从NSObject类继承.
    如果你不继承, 我们的类就无法创建对象, 那么我们的类就毫无意义.
    在NSObject类之中 还定义了1个属性, 这个属性叫做isa指针.
    所以每一个子类对象中都有一个叫做isa的指针.
    NSObject类是OC中所有类的基类, 因为OC中的类全部都是直接的或者间接的从它继承,
 */
/*
 1. 子类中不能存在和父类同名的属性.
    因为子类从父类继承, 就以为这子类拥有了父类的所有的成员 包括属性和方法.
    也就相当于子类中其实已经定义了,
    如果子类在定义1个同名的属性 很明细就冲突了
 2. super关键字
    1). 可以用在类方法和对象方法之中.
    2). 在对象方法中可以使用super关键字调用当前对象从父类继承过来的对象方法.
    3). 在类方法中 super关键字可以调用当前类从父类继承过来的类方法.
        a. 类方法也能被子类继承. 父类中的类方法可以使用父类名来调用 也可以使用子类名调用.
        b. 在子类的类方法中 可以使用super关键字调用父类的类方法.
    4). super只能用来调用父类的对象方法或者类方法 不能用来访问属性.
 3. 子类从父类继承
    1). 相当于子类模版中拥有了父类模版中的所有成员.
    2). 创建1个子类对象, 仍然是根据子类模版来创建对象.
        只不过子类模版中拥有父类模版中的成员.
        所以 子类对象中既有子类的成员, 也有父类的成员.
    3). super特指这个方法是从父类继承过来的.
        super是指当前类或者对象的这个方法是从父类继承过来的.
 */
/*
 1. 访问修饰符: 用来修饰属性的, 可以限定对象的属性在那一段范围之中访问.
    @private: 私有 被@private修饰的属性只能在本类的内部访问.
              只能在本类的方法实现中访问.
    @protected: 受保护的. 被@protected修饰的属性只能在本类和本类的子类中访问.
    @package: 被@package修饰的属性 可以在当前框架中访问.
    @public: 公共的. 被@public修饰的属性 可以在任意的地方访问.
 2. 如果不为属性指定访问修饰符 那么默认的就是@protected
 3. 子类仍然可以继承父类的私有属性.
    只不过, 在子类中无法去直接访问从父类继承过来的私有属性.
    但是如果父类中有一个方法在为属性赋值或者取值
    那么子类可以调用这个方法间接的访问父类的私有属性.
 4. 访问修饰符的作用域.
    从写访问修饰符的地方开始往下, 直到遇到另外1个访问修饰符或者结束大括号为止.
    中间的所有的属性都应用这个访问修饰符.
 5. 使用建议:
    1). @public 无论什么情况下都不要使用, 属性不要直接暴露给外界.
    2). @private 如果属性只想在本类中使用 不想在子类中使用 那么就使用它.
    3). @protected: 如果你希望属性只在本类和本类的子类中使用.
    推荐使用默认的@protected
 6. 访问修饰符只能用来修饰属性, 不能用来修饰方法.
 */
/*
 1. 我们刚才讲的@private修饰的属性就叫做私有属性.
    只能在类的内部访问.
    但是在外界的时候, Xcode仍然会提示这个对象中有这个属性 只不过没权访问.
    我们想要实现的效果: 真私有. 让外界不知道对象里面有这么1个属性.
 2. 其实在@implementation之中也可以写1个大括号
    把属性定义在@implementation的大括号之中.
    这里面的属性. 是1个私有属性. 各种访问修饰符无效.
    外界根本就不会提示.
    讲属性定义在@implementation之中 和 讲属性定义在@interface之中并标记为@private
    唯一的区别: 提示和不提示, 都不能在外界访问.
 3. 私有方法:
    方法不写声明, 只写实现. 那么这个方法就是1个私有方法.
    只能在本类的其他方法中调用 不能再外界调用.
 */
/*
 1. 里氏替换原则  ---  LSP
    子类可以替换父类的位置, 并且程序的功能不受影响.
    为什么?
    1). 父类指针迫切的需求要1个父类对象. 而我们给了1个子类对象,
        这是完全没有问题的, 因为子类就是1个父类嘛.
    2). 因为父类中拥有的成员 子类都有, 所以不会影响程序的功能.
 2. 里氏替换原则的表现形式.
    当一个父类指针指向1个子类对象的时候, 这里就有里氏替换原则.
 3. LSP的作用:
    1). 1个指针中不仅可以存储本类对象的地址还可以存储子类对象的地址.
    2). 如果1个指针的类型是NSObject类型的, 那么这个指针中可以存储任意的OC对象的地址.
    3). 如果1个数组的元素的类型是1个OC指针类型的 那么这个数组中不仅可以存储本类对象还可以存储子类对象.
    4). 如果1个数组的元素是NSObject指针类型 那么意味着任意的OC对象都可以存储到这个数组之中.
    5). 如果1个方法的参数是1个对象, 那么我们在为这个参数传值的时候
        可以传递1个本类对象 也可以传递1个子类对象.
        对方法中的代码不会有丝毫的影响.
 4. 当1个父类指针指向1个子类对象的时候
    这个时候, 通过这个父类指针就只能去调用子类对象中的父类成员.
    子类独有的成员无法访问.
 */
/*
 1. 子类从父类继承, 子类就继承了父类的方法
    子类继承了父类的方法, 就意味着子类拥有了这个功能.
    有的时候, 虽然子类也拥有父类的这个行为. 但是这个行为的具体的实现和父类不同.
 2. 这个时候怎么办?
    拥有父类的行为, 但是行为的具体的实现和父类的实现不一样.
    那么子类就自己按照自己的方式重写这个方法就可以了.
    如何重写: 直接在类的实现中将这个方法重新实现一遍就可以了.
 3. 什么时候子类需要重写父类的方法.
    子类拥有父类的行为, 但是子类这个行为的实现和父类不一样. 那么就按照自己的方式重写这个方法就可以了.
 4. 当1个父类指针指向1个子类对象的时候,
    通过这个父类指针调用的方法 如果在子类中重写了.
    调用的就是子类重写的方法.
 5. 多态
    指的是同1个行为, 对于不同的事物具有完全不同的表现形式.
    找三个人过来: 医生演员理发师, 执行cut指令, 手术 停 理发, 同1个行为 具备多种形态.
 */
/*
 1. %@ 打印的是指针指向的对象.
    %p 打印的是指针变量的值.
 2. 如果我们使用%@打印1个对象
    输出的格式: <对象所属的类名: 对象的地址>
 3. 原理
    当我们使用%@打印1个对象的时候, NSLog含税的底层实现.
    1). 调用传入的对象的description方法.
    2). 拿到这个方法的返回值 这个返回值是1个字符串.
    3). 将这个字符串输出.
 4. description方法是定义在NSObject类之中的.
    所以每一个OC对象都有这个方法.
    这个方法在NSObject类中的实现是这样的:
    返回的字符串格式 @"<对象所属的类名:对象的地址>"
 5. 什么时候需要重写description方法呢?
    如果你希望使用%@打印1个对象的时候 你希望这个对象打印的格式是我们自定义的.
    那么就可以重写这个方法.
 */
/*
 继承的本质
 1. 创建1个对象, 这个对象在内存中是如何分配的.
    1). 子类对象中有自己的属性和所有父类的属性.
    2). 代码段中的每一个类都有1个叫做isa的指针, 这个指针指向它的父类.
        一直指到NSObject
        [p1 sayHi]; // 假设p1是Person对象.
        先根据p1指针找到p1指向的对象, 然后根据对象的isa指针找到Person类.
        搜索Person类中是否有这个sayHi方法 如果有就执行
        如果没有就根据类的isa指针找父类, 以此类推...
        一直找到NSObject, 如果NSObject中也没有, 就报错.
 */
/*
 1. 结构体与类的相同点
    都可以将多个数据封装为1个整体.
    struct Date{
        int year;
        int month;
        int day;
    };
    @interface Date : NSObject{
        int year;
        int month;
        int day;
    }
    @end
 2. 结构体与类的不同点
    1). 结构体只能封装数据, 而类不仅可以封装数据还可以封装行为.
    2). 结构体变量分配在栈空间(如果是1个局部变量的情况下)
        而对象分配在堆空间.
        栈的特点: 空间相对较小. 但是存储在栈中的数据访问的效率更高一些.
        堆的特点: 空间相对较大. 但是存储在堆中的数据访问的效率相对要低.
        存储在栈中的数据访问效率高 存储在堆中的数据访问效率低.
    3). 赋值
        结构体 Student
        类 Person
        Student s1 = {"Jack",19};
        Student s2 = s1;
        Person *p1 = [Person new];
        Person *p2 = p1;
 3. 应用场景
    1). 如果表示的这个实体 不仅是由多个数据组成. 这个实体还有行为, 只能使用类.
    2). 如果表示的实体没有行为, 光有属性.
        a. 如果属性较少. 只有几个. 那么这个时候就定义为结构体 分配在栈 提供效率.
        b. 如果属性较多, 不要定义成结构体. 因为这样结构体变量会在栈中占据很大1块空间
           反而会影响效率.
           定义为类
 */
/*
 类的本质
 1. 内存中的五大区域: 栈, 堆, BSS段, 数据段, 代码段
    代码段是用来存储代码的.
    类加载, 当类第一次被访问的时候 这个类就会被加载到代码段存储起来.
 2. 讨论三个问题
    1). 类什么时候加载到代码段.
        类第一次被访问的时候, 类就会被加载到代码段存储 类加载.
    2). 类以什么样的形式存储在代码段.
    3). 类一旦被加载到代码段之后 什么时候回收.
        是不会被回收的, 除非程序结束.
 3. 类是以什么样的形式存储在代码段的.
    1). 任何存储在内存中的数据都有1个数据类型.
        任何在内存中申请的空间也有自己的类型.
    2). 在代码段存储类的那块空间是个什么类型的.
        在代码段中存储类的步骤:
        a. 先在代码段中创建1个Class对象, Class是Foundation框架中的1个类.
           这个Class对象就是用来存储类信息的.
        b. 将类的信息存储在这个Class对象之中.
           这个Class对象. 至少有3个属性
           类名: 存储的这个类的名称.
           属性们: 存储的这个类具有哪些属性.
           方法们: 存储的这个类具有哪些方法.
        所以类是以Class对象的形式存储在代码段的.
        存储类的这个Class对象 我们也叫做类对象. 用来存储类的1个对象.
        所以 存储类的类对象也有1个叫做isa指针的属性, 这个指针指向存储父类的对象.
 4. 如何拿到存储在代码段中的类对象
    1). 调用类的类方法class就可以得到存储类的类对象的地址.
    2). 调用对象的对象方法class就可以得到存储这个对象所属的类的Class对象的地址.
    3). 对象中的isa指针的值其实就是代码段中存储类的类对象的地址.
    注意:
    声明Class指针的时候, 不需要加* 因为在typedef的时候已经加了*了.
 5. 如何使用类对象.
    1). 拿到存储类的类对象以后.
        Class c1 = [Person new];
        c1对象就是Person类.
        c1 完全等价于Person
    2). 使用类对象来调用类的类方法.
        因为类对象就代表存储在这个类对象中类.
        Class c1 = [Person Class];
        c1 就代表Person类
        所以在使用Person的地方完全可以使用c1代替.
        比如我们使用类名来调用类方法.
        [Person sayHi];
        完全可以使用c1来调用, 因为c1就是Person
        [c1 Person];
    3). 可以使用类对象来调用new方法, 创建存储在类对象中的类的对象.
        Person *p1 = [Person new];
        Class c1 = [Person class];
        其实创建Person对象 也可以这么做.
        Person *p2 = [c1 new];
    4). 注意:
        使用类对象 只能调用类的类方法, 因为类对象就等价于存在其中的类.
        Class c1 = [Person class];
        c1 就是 Person
 6. 总结:
    1). 类是以Class对象的形式存储在代码段之中的.
    2). 如何拿到存储类的类对象
        Class c1 = [Person class];
        Person *p1 = [Person new];
        Class c2 = [p1 class];
    3). 有什么用?
        可以使用类对象调用类的类方法.
        Class c1 = [Person class];
        要调用Person的类方法 可以使用Person去调用, 也可以使用c1去调用.
 */
/*
 方法的本质
 1. SEL 全称叫做selector选择器
    SEL 是1个数据类型. 所以要在内存中申请空间存储数据
    SEL 其实是1个类. SEL对象是用来存储1个方法的.
 2. 类是以Class对象的形式存储在代码段之中.
    类名: 存储的这个类的类名. NSString
    还要将方法存储在类对象之中. 如何将方法存储在类对象之中.
    1). 先创建1个SEL对象.
    2). 将方法的信息存储在这个SEL对象之中.
    3). 再将这个SEL对象作为类对象的属性.
 3. 拿到存储方法的SEL对象.
    1). 因为SEL是1个typedef类型的 在自定义的时候已经加*了.
        所以 我们在声明SEL指针的时候 不需要加*
    2). 取到存储方法的SEL对象.
        SEL s1 = @selector(方法名);
 4. 调用方法的本质.
    [p1 sayHi];
    内部的原理:
    1). 先拿到存储sayHi方法的SEL对象, 也就是拿到存储sayHi方法的SEL数据. SEL消息.
    2). 将这个SEL消息发送给p1对象
    3). 这个时候, p1对象接收到这个SEL消息以后, 就知道要调用方法
    4). 根据对象的isa指针找到存储类的类对象.
    5). 找到这个类对象以后 在这个类对象中去搜寻是否有和传入的SEL数据相匹配的.
        如果有就执行 如果没有再找父类 直到NSObject.
    OC最重要的1个机制: 消息机制.
    调用方法的本质其实就是为对象发送SEL消息.
    [p1 sayHi]; 为p1对象发送1条sayHi消息.
 5. 重点掌握:
    1). 方法是以SEL对象的形式存储起来.
    2). 如何拿到存储方法的SEL对象
 6. 手动的为对象发送SEL消息.
    1). 先得到方法的SEL数据.
    2). 将这个SEL消息发送给p1对象.
        调用对象的方法 将SEL数据发生给对象.
        - (id)performSelector:(SEL)aSelector;
        Person *p1 = [Person new];
        SEL s1 = @selector(sayHi);
        [p1 performSelector:s1]; 与[p1 sayHi];效果是完全一样的.
    3). 调用1个对象的方法有两种:
        1). [对象名 方法名];
        2). 手动的为对象发送SEL消息.
 7. 注意事项:
    1). 如果方法有参数 那么方法名是带了冒号的.
    2). 如果方法有参数, 如何传递参数.
        那么就调用另外1个方法.
        - (id)performSelector:(SEL)aSelector withObject:(id)object;
        - (id)performSelector:(SEL)aSelector withObject:(id)object1 withObject:(id)object2;
    3). 如果有多个参数
        将参数封装成一个类, 调用时传这个类的对象.
 8. 总结:
    1). 类是以Class对象的形式存储在代码段.
    2). 如何取到存储类的类对象
    3). 如何使用类对象调用类的类方法
    4). 方法是以SEL数据的形式存储的.
    5). 调用方法的两种方式
 */
/*
 1. Java, C# 对象可以使用点语法来访问对象的成员.
    OC中也有点语法. OC中也可以使用点语法来访问对象的属性.
    但是OC的点语法和Java C# 是完全不一样的.
    OC的对象如果要为属性赋值或者取值 就要调用对应的getter或者setter.
 2. 使用点语法来访问对象的属性.
    语法:
    对象名.去掉下划线的属性名;
    p1.name = @"jack"; 这个时候就会将@"jack"赋值给p1对象的_name属性.
    NSString *name = p1.name; 把p1对象的_name属性的值取出来.
 3. 点语法的原理.
    p1.age = 19;
    这句话的本质并不是把18直接复制给p1对象的_age属性.
    点语法在编译器编译的时候, 其实会将点语法转换为调用setter, getter的代码.
    1). 当使用点语法赋值的时候. 这个时候编译器会将点语法转换为调用setter方法的代码.
        对象名.去掉下划线的属性名 = 数据;
        转换为:
        [对象名 set去掉下划线的属性名首字母大写:数据];
        p1.age = 10 等价于 [p1 setAge:10];
    2). 当使用点语法取值的时候, 这个时候编译器会将点语法转换为调用getter方法的代码.
        对象名.去掉下划线的属性名;
        转换为:
        [对象名 去掉下划线的属性名];
        int age = p1.age 等价于 int age = [p1 age];
 4. 注意:
    1). 在getter和setter中慎用点语法, 因为有可能会造成无限递归 而程序崩溃
    2). 点语法在编译器编译的时候 会转换为调用setter getter方法的代码.
        如果我们的setter方法和getter方法名不符合规范 那么点语法就会出问题.
    3). 如果属性没有封装getter setter是无法使用点语法的
        因为点语法的本质是getter setter方法.
 */
/*
 语法糖来了!
 1. 我们在写1个类的时候
    a. 要先为类写属性.
    b. 再声明属性的getter setter
    c. 再实现getter setter
    书写量巨大, 有没有更为简单的方式来实现同样的代码效果呢?
 2. @property
    1). 作用: 自动生成getter setter方法的声明.
            因为是生成方法的声明, 所以应该写在@interface类的声明之中.
    2). 语法:
        @property 数据类型 名称;
        @property int age;
    3). 原理:
        编译器在编译的时候, 会根据@property生成getter和setter方法的声明.
        @property 数据类型 名称;
        生成为:
        - (void)set首字母大写的名称:(数据类型)名称;
        - (数据类型) 名称;
        @property int age;
        - (void) setAge:(int)age;
        - (int) age;
 3. 使用@property注意:
    1). @property的类型和属性的类型一致.
        @property的名称和属性的名称一致(去掉下划线)
        不要乱写
    2). @property的名称决定了生成的getter和setter方法的名称.
        所以 @property的名称要和属性的名称一致 去掉下划线 否则生成的方法名就是不符合规范的
        @property的数据类型决定了生成的setter方法的参数类型 和 getter方法的返回值类型.
    3). @property只是生成getter和setter方法的声明. 实现还要自己来, 属性还要自己定义.
 */
/*
 1. @property 只能生成getter和setter的声明. 实现还要我们自己来.
    而实现也没有什么任何技术含量, 方法实现的代码能不能也可以自动生成呢?
 2. @synthesize
    1). 作用: 自动生成getter setter方法的实现.
             所以应该写在类的实现之中.
    2). 语法:
            @synthesize @property名称;
        @interface Person : NSObject
        {
            int _age;
        }
        @property int age;
        @end
        ----
        @implementation Person
        @synthesize age;
        @end
    3). @synthesize做的事情.
        @implementation Person
        @synthesize age;
        @end
        ----
        @implementation Person
        {
            int age;
        }
        - (void) setAge:(int)age
        {
            self->age = age;
        }
        - (int) age
        {
            return age;
        }
        @end
        a. 生成1个真私有的属性. 属性的类型和@synthesize对应的@property类型一致.
           属性的名字和@synthesize对应的@property名字一致.
        b. 自动生成setter方法的实现.
           实现的方式: 将参数直接赋值给自动生成的那个私有属性.并且没有做任何的逻辑验证.
        c. 自动生成getter方法的实现.
           实现的方式: 将生成的私有属性的值返回.
 3. 希望@synthesize不要去自动生成私有属性了.
    getter setter的实现中操作我们已经写好的属性就可以了.
    语法:
    @synthesize @property名称 = 已经存在的属性名;
    @synthesize age = _age;
    1). 不会再去生成私有属性.
    2). 直接生成setter getter的实现
        setter的实现: 把参数的值直接赋值给指定的属性.
        getter的实现: 直接返回指定的属性的值.
 4. 注意:
    1). 如何直接写1个@synthesize
        @synthesize name;
    2). 如何指定操作的属性.
        @synthesize name = _name;
    3). 生成的setter方法实现中 是没有欧任何逻辑验证的 是直接赋值.
        生成的getter方法的实现中 是直接返回属性的值.
        如果setter或者getter有自己的逻辑验证 那么就自己在类的实现中重写就可以了.
 5. 批量声明
    1). 如果多个@property的类型一致, 可以批量声明.
        @property float height, weight;
    2). @synthesize也可以批量声明.
        @synthesize name = _name, age = _age, weight = _weight;
 */
/*
 1. @property只是生成 getter setter的声明.
    @synthesize是生成getter setter的实现.
    这种写法是Xcode4.4之前的写法. 从Xcode4.4以后. Xcode对 @property做了1个增强.
 2. @property增强
    只需要写1个@property编译器就会自动
    1). 生成私有属性.
    2). 生成getter setter的声明.
    3). 生成getter setter的实现.
    @property NSString *name;
    做的事情
    1). 自动的生成1个私有属性, 属性的类型和@property类型一致, 属性的名称和@property的名称一致, 属性的名称自动的加一个下划线.
    2). 自动的生成这个属性的getter setter方法的声明.
    3). 自动的生成这个属性的getter setter方法的实现.
        setter的实现: 直接将参数的值赋值给自动生成的私有属性.
        getter的实现: 直接返回生成的私有属性的值.
 3. 使用注意:
    1). @property的类型一定要和属性的类型一致.
        名称要和属性的名称一致 只是去掉下划线.
    2). 也可以批量声明相同类型的@property
    3). @property生成的方法实现没有做任何逻辑验证.
        setter: 直接赋值
        getter: 之间返回
        所以 我们可以重写setter来自定义验证逻辑, 如果重写了setter 还会自动生成getter
        如果重新了getter 还会自动生成setter
        如果同事重写getter setter那么就不会自动生成私有属性了.
 4. 如果你想为类写一个属性 并且为这个属性封装getter setter
    1个@property就搞定.
 5. 继承.
    父类的@property一样可以被子类继承
    @property生成的属性是私有的 在子类的内部无法直接访问生成的私有属性.
    但是可以通过setter getter来访问.
 */
/*
 动态类型和静态类型
 1. OC是一门弱语言.
    编译器在编译的时候, 语法检查的时候没有那么严格.
    不管你怎么写都是可以的.
    int num = 12.12;
    优点: 灵活, 咋个写都行
    缺点: 太灵活
    强类型的语言: 编译器在编译的时候 做语法检查的时候 行就是行 不行就是不行.
 2. 静态类型:
    指的是1个指针指向的对象是1个本类对象.
    动态类型:
    指的是1个指针指向的对象不是本类对象.
 3. 编译检查.
    编译器在编译的时候, 能不能通过1个指针去调用指针指向的对象的方法?
    判断原则: 看指针所属的类型之中是否有这个方法, 如果有就认为可以调用 编译通过.
            如果这个类中没有 那么编译报错.
            这个叫做编译检查. 在编译的时候 能不能调用对象的方法主要是看指针的类型.
            我们可以将指针的类型做转换, 来达到骗过编译器的目的. [(Pig *)a1 eat];
            Animal *a1 = [Pig new];
            [a1 eat]; 编译报错, 因为Animal类中没有eat方法,
            NSString *str = [Person new];
            [str length]; 不报错, 因为NSString有length方法, 但是运行会报错, 因为Person没有length方法,
            口诀: 编译看左, 运行看右.
 4. 运行检查.
    编译检查只是骗过了编译器. 但是这个方法究竟能不能执行?
    所以在运行的时候, 运行是会去检查对象中是否真的有这个方法, 如果有就执行, 如果没有就报错.
 5. LSP
    父类指针指向子类对象
    实际上任意指针可以指向任意的对象. 编译器是不会报错的.
    当1个子类指针指向1个父类对象的时候, 编译器运行通过子类指针去调用子类独有的方法.
    但是在运行的时候是会出问题的, 因为父类对象中根本没有子类成员.
 */
/*
 1. NSObject
    是OC中所有类的基类. 根据LSP NSObject指针就可以指向任意的OC对象.
    所以NSObject指针是1个万能指针. 可以指向任意的OC对象.
    缺点: 如果要调用指向的子类对象的独有的方法, 就必须要做类型转换.
 2. id指针.
    是1个万能指针, 可以指向任意的OC对象.
    1). id是1个typedef自定义类型 在定义的时候已经加了*
        所以 声明id指针的时候不需要再加*了.
    2). id指针是1个万能指针, 任意的OC对象都可以指.
 3. NSObject和id的异同.
    相同点: 万能指针 都可以指向任意的OC对象.
    不同点: 通过NSObject指针去调用对象的方法的时候, 编译器会做编译检查.
           通过id类型的指针去调用对象的方法的时候, 编译器直接通过. 无论你调用什么方法.
    注意: id指针只能调用对象的方法 不能使用->访问属性, 也不能使用点语法, 如果使用点语法就会直接报编译错误.
    如果我们要声明一个万能指针 千万不要使用NSObject 而是使用id
 4. 父类中的类方法创建1个父类对象返回.
    1). 如果返回值写为父类类型的. 那么子类来调用这个方法得到的就是父类指针.
        解决的方式: 把返回值改为id类型的
    2). 方法的内部创建对象的时候 不要写死. 因为写死创建的对象就固定了.
        我们希望那1个类来调用这个方法就创建那1个类的对象.
        把类名写为self那1个类来调用这个方法self就指的是那1个类.创建的就是那1个类的对象.
    3). 方法的返回值是id类型的, 问题就是任意指针都可以接收这个方法的返回值.
        编译器连个警告都没有.
        如果方法的返回值是instancetype
        代表方法的返回值是当前这个类的对象.
 5. 使用建议
    1). 如果方法内部是在创建当前类的对象, 不要写死成类名 [类名 new];
        而是用self代替类名.
    2). 如果方法的返回值是当前类的对象, 也不要写死了, 而是写instancetype
 6. id和instancetype的区别.
    1). instancetype只能作为方法的返回值, 不能在别的方法使用
        id既可以声明指针变量 也可以作为参数 也可以作为返回值.
    2). instancetype是1个有类型的 代表当前类的对象.
        id是1个无类型的指针 仅仅是1个地址, 没有类型的指针.
 */
/*
 1. 编译检查
    编译器在编译的时候, 判断1个指针是否可以调用指向的对象的方法.
    判断的准则就是指针的类型
    LLVM
    我们可以很轻松的把编译器给骗过.
 2. 就算骗过了编译器, 程序在运行的时候还会做运行检查.
    我们写的程序就算编译通过了, 不意味着可以完美的执行.
 3. 我们就希望, 我们可以写代码来先判断1下, 对象中是否有这个方法, 如果有再去执行.
    如果没有就别去执行.
    1). 判断对象中是否有这个方法可以执行.
        -(BOOL)respondsToSelector:(SEL)aSelector;
        最常用的是这个方法.
    2). 判断类中是否有指定的类方法.
        +(BOOL)instanceRespondsToSelector:(SEL)aSelector;
    3). 判断指定的对象是否为 指定类的对象或者子类对象.
        -(BOOL)isKindOfClass:(Class)aClass;
        BOOL b1 = [s1 isKindOfClass:[Person class]];
        判断s1对象是否为Person对象或者Person的子类对象.
    4). 判断对象是否为指定类的对象 不包括子类.
        -(BOOL)isMemberOfClass:(Class)aClass;
        BOOL b1 = [s1 isMemberOfClass:[Student class]];
        判断s1对象是否为1个Student对象.不包括Student的子类对象.
    5). 判断类是否为另外1个类的子类.
        +(BOOL)isSubclassOfClass:(Class)aClass;
        [Student isSubclassOfClass:[Person class]];
 */
/*
 1. 创建对象
    类名 *指针名 = [类名 new];
    new实际上是1个类方法.
    new方法的作用: ->创建对象 ->初始化对象 ->把对象的地址返回
    new方法的内部, 其实是先调用的alloc方法. 再调用的init方法.
    alloc方法是1个类方法, 作用: 那1个类调用这个方法 就创建那个类的对象, 并把东西返回.
    init方法 是1个对象方法, 作用: 初始化对象.
    创建对象的完整步骤:
    应该是先使用alloc创建1个对象, 然后在使用init初始化这个对象, 才可以使用这个对象.
    虽然没有初始化的对象 有的时候 也可以使用, 但是千万不要这么做.
    使用1个未经初始化的对象是机器危险的.
    Person *p1 = [Person new];
    完全等价于 Person *p1 = [[Person alloc] init];
 2. init方法.
    作用: 初始化对象, 为对象的属性赋初始值 这个init方法我们叫做构造方法.
         init方法做的事情: 初始化对象.
         为对象的属性赋默认值.
         如果属性的类型是基本数据类型就赋值为0, C指针->NULL, OC指针->nil
         所以 我们创建1个对象如果没有为这个对象的属性赋值 这个对象的属性是由默认值的.
         所以 我们每次新创建1个对象, 这个对象的属性都被初始化了.
 3. 我们想要让创建的对象的属性的默认值不是nil NULL 0;
    而是我们自定义的.
    那么这个时候, 我们就可以重写init方法. 在这个方法中按照我们自己的想法为对象的属性赋值.
    重写init方法的规范:
    1). 必须要先调用父类的init方法, 然后将方法的返回值赋值给self
    2). 调用init方法初始化对象有可能会失败, 如果初始化失败. 返回的就是nil
    3). 判断父类是否初始化成功. 判断self的值是否为nil 如果部位nil说明初始化成功.
    4). 如果初始化成功 就初始化当前对象的属性.
    5). 最后返回self的值.
    解惑:
    1). 为什么要调用父类的init方法.
        因为父类的init方法 会初始化父类的属性. 所以必须要保证当前对象中的父类属性也同时被初始化.
    2). 为什么要赋值给self?
        因为 调用父类的init方法 会返回初始化成功对象.
        实际上返回的就是当前对象. 但是我们要判断是否初始化成功.
    无论如何, 记住重写init方法的规范.
    -(instancetype)init
    {
        if(self = [super init]){
            //初始化当前类的属性的代码;
    }
        return self;
    }
    什么时候需要重写init方法:
    如果你希望创建出来的对象的属性的默认值不是 nil NULL 0 而是我们指定的值.
    那么这个时候我们就可以重写init方法.
 3. 重写init方法以后.
    每次创建出来的对象的属性的值都是一样的.
    创建对象的时候, 对象的属性的值由创建对象的人来指定, 而不是写死在init方法中.
    自定义构造方法:
    规范:
    1). 自定义构造方法的返回值必须是instancetype
    2). 自定义构造方法的名称必须以initWith开头.
    3). 方法的实现和init的要求一样.
    什么时候要自定义构造方法?
    如果你希望在创建对象的同时就指定对象的属性值.
 */


 1. 内存管理
    内存的作用: 存储数据
    1). 如何将数据存储到内存之中
        声明1个变量, 然后将数据存储进去.
    2). 当数据不再被使用的时候, 占用的内存空间如何被释放.
 2. 内存中的五大区域
    栈: 局部变量, 当局部变量的作用域被执行完毕之后, 这个局部变量就会被系统立即回收.
    堆: OC对象. 使用C函数申请的空间.
    BSS段: 未初始化的全局变量, 静态变量. 一旦初始化就回收, 并转存到数据段之中.
    数据段: 已经初始化的全局变量, 静态变量. 直到程序结束的时候才会被回收.
    代码段: 代码, 程序结束的时候, 系统会自动回收存储在代码段中的数据.
 
    栈, BSS段, 数据段, 代码段 存储在他们中的数据的回收, 是由系统自动完成的, 不需要我们干预.
 3. 分配在堆区中的OC对象, 是肯定需要被回收的.
    存储在堆中的OC对象, 系统不会自动回收, 直到程序结束的时候才会被回收.
 4. 内存管理的范围:
    只需要管理存储在堆中的OC对象的回收, 其他区域中的数据的回收是系统自己管理的.
 5. 对象应该什么时候被回收?
    当有人使用这个对象的时候, 这个对象就千万不能回收,
    只有在没有任何人使用这个对象的时候, 才可以回收
 6. 引用计数器
    1). 每一个对象都有一个属性, 叫做retainCount, 叫做引用计数器. 类型是unsigned long 占据8个字节.
        引用计数器的作用: 用来记录当前这个对象有多少个人在使用它.
        默认情况下, 创建1个对象出来, 这个对象的引用计数器的默认值是1.
    2). 当多1个人使用这个对象的时候. 应该先让这个对象的引用计数器的值+1 代表这个对象多1个人使用.
    3). 当这个对象少1个人使用的时候. 应该先让这个对象的引用计数器的值-1 代表这个对象少1个人使用.
    4). 当这个对象少的引用计数器变为0的时候, 代表这个对象无人使用. 这个时候系统就会自动回收这个对象.
 7. 如何操作引用计数器.
    1). 为对象发送1条retain消息, 对象的引用计数器就会加1, 当多1个人使用对象的时候才发.
    2). 为对象发送1条release消息, 对象的引用计数器就会减1, 当少1个人使用对象的时候才发.
    3). 为对象发送1条retainCount消息, 就可以取到对象的引用计数器的值.
    就这样++-- 当对象的引用计数器变为0的时候, 对象就会被系统立即回收.
    在对象被回收的时候, 会自动调用对象的dealloc方法.
 8. 内存管理的分类
    MRC: Manual Reference Counting 手动引用计数, 手动内存管理.
         当多1个人使用对象的时候, 要求程序员手动的发送retain消息, 少1个人使用的时候程序员手动的发送relase消息.
    ARC: Automatic Reference Counting 自动引用计数, 自动内存管理.
         系统自动的在合适的地方发送retain release消息.
    学习MRC的理由:
    1). 面试必考
    2). 早期APP开发使用的MRC技术
    3). iOS大牛都是从MRC成长起来的
    4). ARC是基于MRC
 */
/*
 从iOS5开始, Xcode4.2开始支持ARC, Xcode7默认支持ARC开发. 默认使用的开发方式就是ARC模式.
 关闭ARC开启MRC,
 2. 当对象的引用计数器变为0的时候, 系统会自动回收对象.
    在系统回收对象的时候. 会自动的调用对象的dealloc方法
    重写dealloc方法的规范:
    必须要调用父类的dealloc方法. 并且要放在最后一句代码.
 3. 测试引用计数器.
    1). 新创建1个对象, 这个对象的引用计数器的值默认是1.
    2). 当对象的引用计数器变为0的时候, 对象就会被系统立即回收 并自动调用dealloc方法.
    3). 为对象发送retain消息 对象的引用计数器就会+1
 4. 为对象发送release消息, 并不是回收对象, 而是让对象的引用计数器-1
    当对象的引用计数器的值变为0的时候, 对象才会被系统立即回收.
 */
/*
 1. 内存管理的重点:
    1). 什么时候为对象发送retain消息?
        当多1个人使用这个对象的时候, 应该先为这个对象发送retain消息.
    2). 什么时候为对象发送release消息?
        当少1个人使用这个对象的时候,应该为这个对象发送1条release消息.
 2. 在ARC机制下, retain release dealloc这些方法无法调用.
 3. 内存管理的原则.
    1). 有对象的创建, 就要匹配1个release
    2). retain的次数和release的次数要匹配
    3). 谁用谁retain, 谁不用谁release
        谁负责retain 谁就负责release
    4). 只有在多1个人用的时候才retain 少1个人使用的时候才release
    有始有终, 有加有减, 有retain就应该匹配1个release一定要平衡.
 */
/*
 1. 野指针
    C语言中的野指针: 定义1个指针变量, 没有初始化, 这个指针变量的值是1个垃圾值, 指向1块随机的空间, 这个指针就叫做野指针.
    OC中的野指针: 指针指向的对象已经被回收了, 这样的指针就叫做野指针.
 2. 对象回收的本质.
    内存回收的本质:
    申请1个变量, 实际上就是向系统申请指定字节数的空间. 这些空间系统就不会再分配给别人了.
    当变量被回收的时候, 代表变量占用的字节空间从此以后系统可以分配给别人使用了.
    但是字节空间中存储的数据还在.
    回收对象:
    所谓的对象的回收, 指的是对象占用的空间可以分配给别人.
    当这个对象占用的空间没有分配给别人之前 其实对象数据还在.
 3. 僵尸对象
    1个已经被释放的对象, 但是这个对象所占的空间还没有分配给别人. 这样的对象叫做僵尸对象.
    我们通过野指针去访问僵尸对象的时候, 有可能没问题, 也有可能有问题.
    当僵尸对象占用的空间还没有分配给别人的时候, 这是可以的.
    当僵尸对象占用的空间分配给了别人使用的时候, 就不可以.
 4. 我们认为只有对象成为了僵尸对象, 无论如何 都不允许访问了.
    就希望如果访问的是僵尸对象, 无论如何报错
    僵尸对象的实时检查机制, 可以将这个机制打开, 打开之后. 只要访问的是僵尸对象, 无论空间是否分配, 就会报错.
 5. 为什么不默认打开僵尸对象检测.
    一旦打开僵尸对象检测 那么在每访问1个对象的时候, 都会先检查这个对象是否为1个僵尸对象,
    这样是极其小号性能的.
 6. 使用野指针访问僵尸对象会报错, 如何避免僵尸对象错误.
    当1个指针成为野指针以后, 将这个指针的值设置nil
    当1个指针的值为nil 通过这个指针去调用对象的方法(包括使用点语法)的时候, 不会报错, 只是没有任何反应.
    但是如果通过直接访问属性 -> 就会报错.
 7. 无法复活1个僵尸对象.
 */
/*
 1. 内存泄露:
    指的是1个对象没有被及时的回收, 在该回收的时候而没有被回收
    一直驻留在内存中, 直到程序结束的时候才回收.
 2. 单个对象的内存泄露的情况.
    1). 有对象的创建, 而没有对应的release
    2). retain的次数和release的次数不匹配.
    3). 在不适当的时候, 为指针赋值为nil
    4). 在方法中为传入的对象进行不适当的retain
 3. 如何保证单个对象可以被回收
    1). 有对象的创建, 就必须要匹配1个release
    2). retain次数和release次数一定要匹配
    3). 只有在指针成为野指针的时候才赋值为nil
    4). 在方法中不要随意的为传入的对象retain.
 */
/*
 多个对象的内存管理
 1. 当属性是1个OC对象的时候, setter方法的写法
    将传进来的对象赋值给当前对象的属性, 代表传入的对象多了1个人使用, 所以我们应该先为这个传入的对象发送1条retain消息, 再赋值.
    [对象名 retain];
    当当前对象销毁的时候, 代表属性指向的对象少1个人使用, 就应该在dealloc中release
    代码写法:
    - (void) setCar:(Car *)car
    {
        //将传入的车对象赋值给当前对象的_car属性,
        //代表: 传入的对象多了1个人使用.
        //那么就应该先为这个对象发送1条retain消息
        [_car release]; // 新增
        _car = [car retain];
        //为传进来的对象发送1天retain消息, 让他的引用计数器的值+1 代表多1个人使用.
        //再将传入的对象赋值给当前对象的_car属性.
 
        //当我们将闯入的Car对象赋值给_car属性的时候
        //代表1: _car属性原本指向的对象少1个人使用
        //代表2: 传入的对象多1个使用
        //所以 我们应该先将_car属性原本指向的对象release 再将传入的新对象retain
    }
    - (void) dealloc
    {
        //当对象销毁的时候, 代表当前这个对象就不会再使用_car指向的对象了.
        //我们说, 当不再使用1个对象的时候 应该为这个对象发送1条release消息
        [_car release];
        [super dealloc];
    }
 2. 当属性是1个OC对象的时候, setter方法照着上面那样写, 其实还是有bug的.
    当为对象的这个属性多次赋值的时候, 就会发生内存泄露.
    发生泄露的原因: 当为属性赋值的时候, 代表旧对象少1个人用, 新对象多1个人使用.
    应该release旧的 retain新的.
 3. 出现的僵尸对象错误的原因:
    在于 新旧对象是同1个对象.
    解决的方案: 当发现新旧对象是同1个对象的时候, 什么都不用做.
              只有当新旧对象不是同1个对象的时候, 才release旧的 retain新的.
     最终完美版的setter方法的写法 应该这样写
     if(_car != car) {//说明新旧对象不是同一个对象.
        [_car release];//才去release旧的
        _car = [car retain];//retain新的
     }
 4. 特别注意
    我们内存管理的范围是OC对象
    所以, 只有属性的类型是OC对象的时候, 这个属性的setter方法才要像上面那样写.
    如果属性不是OC对象类型的 setter方法直接赋值就可以了.
 */
/*
 1. 在MRC的开发模式下, 1个类的属性如果是1个OC对象类型的, 那么这个属性的setter方法就应该按照下面的格式写.
    如果属性的类型不是OC对象类型的, 不需要像下面这样写, 还是像之前那样写就OK了.
 -(void)setCar:(Car *)car{
    if(_car != car){
        [_car release];
        _car = [car retain];
    }
 }
 还要重写dealloc方法
 -(void)dealloc{
    [_car release];
    [super dealloc];
 }
 2. @property
    1). 作用
        a. 自动生成私有属性
        b. 自动生成这个属性的getter setter方法的声明.
        c. 自动生成这个属性的getter setter方法的实现.
        特别注意:
        生成的setter方法的实现中, 无论是什么类型的, 都是直接赋值.
 
 3. @property参数
    1). @property可以带参数的.
        @property(参数1, 参数2, 参数3...)数据类型 名称;
    2). 介绍一下@property的四组参数.
        a. 与多线程相关的两个参数.
           atomic, nonatomic
        b. 与生成的setter方法的实现相关的参数.
           assign, retain
        c. 与生成只读, 读写相关的参数
           readonly, readwrite
        d. 是与生成的getter setter方法名字相关的参数.
           getter setter
 
 4. 介绍与多线程相关的参数.
    atomic: 默认值. 如果写atomic, 这个时候生成的setter方法的代码就会被加上一把线程安全锁.
            特点: 安全, 效率低下.
    nonatomic: 如果写nonatomic, 这个时候生成的setter方法的代码就不会加线程安全锁.
            特点: 不安全, 但是效率高.
    建议: 要效率, 选择使用nonatomic 在没有讲解多线程的知识以前, 统统使用nonatomic
 
 5. 与生成的setter方法的实现相关的参数.
    assign: 默认值, 生成的setter方法的实现就是直接赋值.
    retain: 生成的setter方法的实现就是标准的MRC内存管理代码.
            也就是. 先判断新旧对象是否为同1个对象, 如果不是 release旧的, retain新的.
    当属性的类型是OC对象类型的时候, 那么就使用retain
    当属性的类型是非OC对象的时候, 使用assign
    千万注意:
    retain参数, 只是生成标准的setter方法为标准的MRC内存管理代码, 不会自动的在dealloc中生成release的代码.
    所以 我们还要自己手动的在dealloc中release
 6. 与生成只读, 读写的封装
    readwrite: 默认值, 代表同时生成getter setter
    readonly: 只会生成getter 不会生成setter
 7. 生成的getter setter方法名字相关的参数
    默认情况下. @property生成的getter setter方法的名字都是最标准的名字
    其实我们可以通过参数来指定@property生成的方法的名字
    getter = getter方法名字 用来指定@property生成的getter方法的名字.
    setter = setter方法名字 用来指定@property生成的setter方法的名字. 注意: setter方法是带参数的 所以要加1个冒号.
    记住: 如果使用getter setter修改了生成的方法的名字
         在使用点语法的时候, 编译器会转换为调用修改后的名字的代码.
    修改生成getter setter方法名字, 因为默认情况下生成的方法的名字已经是最标准的名字了, 所以 一般情况下不要去改.
    1). 无论什么情况都不要改setter方法的名字. 因为默认情况下生成的名字就 已经是最标准的了.
    2). 什么时候改getter方法的名字, 当属性的类型是1个BOOL类型的时候, 就修改这个getter的名字以is开头 提高代码的阅读性.
 
 ------总结------
 1. 与多线程相关的参数: 用nonatomic
 2. 与生成的setter方法实现相关的参数
    属性的类型是OC对象的时候, 使用retain
    属性的类型是非OC对象的时候, 使用assign
 3. 只读 读写
    如果你希望生成的封装是只读封装 那么就使用readonly
    如果你希望读写封装 readwrite
 4. 不要改setter方法的名字, 因为它最标准.
    当属性的类似是BOOL类型的时候, 可以将getter方法的名字前加is, 提高代码的阅读性
 ------使用参数注意------
 1. 同1组参数只能使用1个.
    getter setter可以同时使用.
 2. 参数的顺序可以随意.
    一般第一个写nonatomic
 */
/*
 1. 当两个类相互包含的时候. 当Person.h中包含Book.h 而Book.h中有包含Person.h
    这个时候 就会出现循环引用的问题, 就会造成无限递归的问题, 而导致无法编译通过.
 2. 解决方案:
    其中一遍不要使用#import引入对方的头文件.
    而是使用@class 类名; 来标注这是1个类, 这样子就可以在不引入对方头文件的情况下, 告诉编译器这是1个类.
    在.m文件中再#import对方的头文件. 就可以使用了.
 3. @class与#import的区别
    1). #import是将指定的文件的内容拷贝到写指令的地方.
    2). @class 并不会拷贝任何内容. 只是告诉编译器 这是1个类, 这样编译器在编译的时候才可以知道这是1个类.
 */
/*
 1. 当两个对象相互引用的时候.
    A对象的属性是B对象 B对象的属性是A对象
    这个时候 如果两边都使用retain 那么就会发送内存泄露
 2. 解决方案: 1端使用retain 另外1端使用assign 使用assign的那一端在dealloc中不再需要release了.
 */
/*
 引用计数器的改变只能调用retain release 不能直接赋值.
 [super dealloc];最后调用, 是因为子类中有父类的属性, 而父类属性的release是放在父类的dealloc方法之中的.
 为了能够释放所有的对象 必须要调用父类的dealloc方法.
 开启僵尸对象检测, 当调用了僵尸对象方法后会立即报错, 可以给野指针赋值为nil, 来避免调用僵尸对象报错.
 */
/*
 1. 自动释放池的原理
    存入到自动释放池中的对象, 在自动释放池被销毁的时候, 会自动调用存储在该自动释放池中的所有对象的release方法.
    可以解决的问题:
    将创建的对象, 存入到自动释放池之中, 就不再需要手动的release这个对象了.
    因为池子销毁的时候 就会自动的调用池中所有的对象的release
    自动释放池的好处: 将创建的对象存储到自动释放池中, 不需要再写release了.
 2. 如何创建自动释放池.
    @autoreleasepool{}
    这对大括号代表这个自动释放池的范围.
 3. 如何将对象存储到自动释放池之中.
    在自动释放池之中调用对象的autorelease方法, 就会将这个对象存入到当前自动释放池之中.
    这个autorelease方法返回的事对象本身, 所以我们可以这么写.
    @autoreleasepool
    {
        Person *p1 = [[[Person alloc] init] autorelease];
    }
    这个时候, 当这个自动释放池执行完毕之后, 就会立即为这个自动释放池中的对象发送1条release消息.
    目前为止, 我们感受到的autorelease的好处;
    创建对象, 调用对象的autorelease方法, 将这个对象存入到当前的自动释放池之中.
    我们就不需要再去release 因为自动释放池销毁的时候 就会自动的调用池中所有对象的release
 4. 使用注意:
    1). 只有在自动释放池中调用了对象的autorelease方法, 这个对象才会被存储到这个自动释放池之中.
        如果只是将对象的创建代码写在自动释放池之中, 而没有调用对象的autorelease方法, 是不会将这个对象存储到这个自动释放池之中的.
    2). 对象的创建可以在自动释放池的外面, 在自动释放池之中, 调用对象的autorelease方法, 就可以将这个对象存储到这个自动释放池之中.
    3). 如果对象的autorelease方法的调用放在自动释放池的外面, 是无法将其存储的这个自动释放池之中的.
        autorelease的调用只有放在自动释放池之中 才可以将其存储到自动释放池之中, 对象的创建可以在外面.
    4). 当自动释放池结束的时候, 仅仅是对存储在自动释放池中的对象发送1条release消息, 而不是销毁对象.
    5). 如果在自动释放池中, 调用同1个对象的autorelease方法多次, 就会将对象存储多次到自动释放池之中.
        在自动释放池结束的时候, 会为对象发送多条release消息. 那么这个时候就会出现僵尸对象错误.
        所以, 1个自动释放池之中, 只autorelease1次, 只将这个对象放1次, 否则就会出现野指针错误.
    6). 如果在自动释放池中, 调用了存储到自动释放池中的对象的release方法.
        在自动释放池结束的时候, 还会再调用对象的release方法.
        这个时候就有可能会造成野指针操作.
        也可以调用存储在自动释放池中的对象的retain方法, 但是会造成内存泄露, 需要release平衡才行
    7). 将对象存储到自动释放池, 并不会是对象的引用计数器+1
        所以其好处就是: 创建对象将对象存储在自动释放池, 就不需要再写个release了.
    8). 自动释放池可以嵌套.
        调用对象的autorelease方法, 会将对象加入到当前自动释放池之中
        只有在当前自动释放池结束的时候才会像对象发送release消息.
 5. autorelease的应用场景.
    0). 创建对象, 将对象存储到自动释放池之中, 就不需要再去手动的release
 
    1). 类方法的第一规范:
        一般情况下, 要求提供与自定义构造方法相同功能的类方法, 这样可以快速的创建1个对象.
 
    2). 我们一般情况下, 写1个类, 会为我们的类写1个同名的类方法, 用来让外界调用类方法来快速的得到1个对象.
        规范: 使用类方法创建的对象, 要求这个对象在方法中就已经被autorelease过了.
        这样, 我们只要在自动释放池中, 调用类方法来创建对象, 那么创建的对象就会被自动的加入到自动释放池中.
        提供1个类方法来快速的得到1个对象.
        规范
        a. 这个类方法以类名开头. 如果没有参数就直接是类名 如果有参数就是 类名WithXX:
        b. 使用类方法得到的对象, 要求这个对象就已经被autorelease过了.
        + (instancetype)person
        {
            return [[[self alloc] init] autorelease];
        }
        这样我们直接调用类方法, 就可以得到1个已经被autorelease过的对象.
        @autoreleasepool
        {
            Person *p1 = [Person person];
            //这个p1对象已经被autorelease过了, 不需要在调用autorelease
            //这个p1对象就被存储到当前自动释放池之中.
        }//当自动释放池结束, 就会为存储在其中的p1对象发送release消息.
 6. 实际上Apple的框架中的类也是遵守这个规范的.
    通过类方法创建的对象都是已经被autorelease过的了.
    所以, 我们也要遵守这个规范, 类方法返回的对象也要被autorelease过.
    以后, 我们凡是创建对象是调用类方法创建的对象, 这个对象已经是被autorelease过的了.
 */
/*
 ----结构体和类的区别----
 1. 结构体只能封装属性, 而类不仅可以封装属性还可以封装方法.
    如果1个封装数据既有属性也有行为,只能用类.
 2. 结构体变量分配在栈, OC对象分配在堆.
    栈的空间相对较小. 但是存储在栈中的数据访问效率相对较高.
    堆的空间相对较大. 但是存储在堆中的数据访问效率相对较低.
    如果1个封装数据只有属性, 如果用结构体就会分配在栈 效率就会高.
                         如果使用类, 对象就分配在堆, 效率相对就会低.
    如果定义1个结构体, 这个结构体中有很多个属性, 那么这个时候结构体变量在栈中就会占据很大1块空间, 反而会降低效率.
    什么时候使用结构体: 1)封装数据只有属性 2)属性较少, 3个以下.
    什么时候使用类: 1)封装数据既有属性也有行为 2)只有属性, 但是属性较多.
 3. 结构体赋值是直接赋值的值. 而对象的指针 赋值的是对象的地址.
 */
/*
 1. 什么是ARC
    Automatic Reference Counting, 自动引用计数. 即ARC.
    顾名思义: 系统自动的帮助我们去计算对象的引用计数器的值,
    可以说是WWDC2011和iOS5引入的最大的变革和最激动人心的变化.
    ARC是新的LLVM3.0编译器的一项特性, 使用ARC, 可以说一举解决了广大iOS开发者憎恨的手动管理内存的麻烦.
    在程序中使用ARC非常简单, 只需要像往常那样编写代码.
    只不过永远不要写retain, release, autorelease这三个关键字就好, 这是ARC的最基本的原则. 永远不要手动调用dealloc, 会报错.
    当ARC开启时, 编译器会自动的在合适的地方插入retain, release, autorelease代码.
    编译器自动为对象做引用计数, 而作为开发者, 完全不需要担心编译器会做错(除非开发者自己用错了ARC).
    需要特别注意的是: ARC是编译器机制, 在编译器编译代码的时候, 会在适时的位置加入retain, release和autorelease代码.
 2. ARC机制下, 对象何时被释放
    本质: 对象的引用计数器为0的时候, 自动释放.
    表象: 只要没有强指针指向这个对象, 这个对象就会立即回收.
 3. 强指针与弱指针.
    强指针: 默认情况下, 我们声明1个指针 这个指针就是1个强指针.
           我们也可以使用__strong来显示的声明这是1个强指针.
    Person *p1; 这是1个强指针. 指针默认情况下都是1个强指针.
    __strong Person *p2; 这也是1个强指针, 使用__strong来显示的声明强指针.
    弱指针: 使用__weak标识的指针就叫做弱指针.
    无论是强指针还是弱指针, 都是指针, 都可以用来存储地址, 这1点没有任何区别.
    都可以通过这个指针访问对象的成员.
    唯一的区别就是在ARC模式下, 他们用来作为回收对象的基准.
    如果1个对象没有任何强类型的指针指向这个对象的时候, 对象就会被立即自动释放
 4. 确认程序是否开启ARC机制.
    1). 默认情况下, Xcode开启ARC机制.
    2). ARC机制下, 不允许调用retain, release, retainCount, autorelease方法.
    3). 在dealloc中 不允许[super dealloc];
 5. 演示1个ARC案例
    int main(int argc, const char * argv[]){
        @autoreleasepool{
            Person *p1 = [Person new]; // p1是1个强指针.
            //因为我们说过, 每一个指针变量默认情况下都是1个强指针变量.
        }//当执行到这里的时候, p1指针被回收, 那么Person对象就没有任何强指针指向它了, 对象就在这被回收.
        return 0;
    }
 */
/*
 1. ARC下的单个对象的内存管理
    在ARC的机制下: 当1个对象没有任何的强指针指向它的时候, 这个对象就会被立即回收.
    1). 当指向对象的所有的强指针被回收的时候, 对象就会被立即回收.
        int main(int argc, const char * argv[]){
            @autoreleasepool{
                Person *p1 = [Person new]; // p1是1个强指针.
                Person *p2 = p1; // p2也是个强指针. p1和p2都指向Person对象.
                //因为我们说过, 每一个指针变量默认情况下都是1个强指针变量.
            }//当执行到这里的时候, p1指针被回收, p2指针也被回收, 那么Person对象就没有任何强指针指向它了, 对象就在这被回收.
            return 0;
        }
    2). 将所有指向对象的强指针赋值为nil的时候, 对象就会被立即回收.
        int main(int argc, const char * argv[]){
            @autoreleasepool{
                Person *p1 = [Person new]; // p1是1个强指针.
                //因为我们说过, 每一个指针变量默认情况下都是1个强指针变量.
                p1 = nil; // 当执行到这句话的时候, p1赋值为nil.
                //p1指针不再指向Person对象.
                //Person对象没有被任何的指针所指向, 所以Person对象在这里被释放.
            }
            return 0;
        }
    这两种情况就叫做没有任何强指针指向对象.
    1). 指向对象的所有强指针被回收掉
    2). 指向对象的所有的强指针赋值为nil.
 2. 强指针与弱指针.
    1). 强指针与弱指针的声明.
        默认情况下, 所有的指针都是强类型的, 也就是说我们之前声明的指针变量都是强类型的.
        p1指针是强类型的, 因为默认情况下指针都是强类型的.
        Person *p1 = [[Person alloc] init];
        不过我们可以使用__strong来显示的标识指针是强类型指针.
        __strong Person *p2 = [Person new];
        这个时候p2指针类型是强指针类型的, 其实写不写__strong都是强类型的指针.
        指针类型也可以是弱指针类型.
        使用__weak标识指针的类型是弱类型指针.
        __weak Person *p3 = p2;
        这个时候, p3指针就是1个弱类型的指针, p3弱指针也指向p2指针指向的对象.
        在操作对象的时候, 通过强指针或者弱指针都可以操作, 没有任何区别.
    2). ARC模式下的对象回收标准.
        ARC机制下释放1个对象的标准是: 没有任何强指针指向对象的时候, 对象就会被释放.
        如果这个时候有弱指针指向, 也会被释放.
    3). 最重要的1点: 不能创建对象用1个弱指针存储这个对象的指针.
        这样的话, 刚创建出来的对象, 就没有任何强指针指向, 创建出来就会被回收.
        int main(int argc, const char * argv[]){
            @autoreleasepool{
                //创建1个对象, 将这个对象的地址赋值给1个弱指针
                //后果就是创建出来的这个对象没有被任何强指针指向.
                //刚创建出来就会被释放.
                __weak Person *p1 = [Person new];
             }
             return 0;
         }
    4). 在ARC机制下, 当对象被回收的时候, 原来指向这个对象的弱指针会被自动设置为nil.
 */
/*
 1. ARC机制下的对象的回收的标准: 当没有任何强类型的指针指向对象的时候, 这个对象就会被立即回收.
 2. 强类型指针 弱类型指针.
 3. 什么情况下叫做对象没有强指针指向
    1). 指向对象的强指针被回收.
    2). 指向对象的强指针被赋值为nil
 4. 在ARC的机制下, @property参数不能使用retain
    因为retain代表生成的setter方法是MRC的标准的内存管理代码.
    而我们在ARC的机制下, 不需要这些代码.
    所以 在ARC机制下的setter方法 什么都不需要做, 直接赋值就可以了,
 5. ARC机制下, 我们关注的重点
    当1个类的属性是1个OC对象的时候, 这个属性应该声明为强类型的还是弱类型的.
    很明显, 应该声明为1个强类型的.
    如何控制@property生成的是由属性, 是1个强类型的还是1个弱类型的呢?
    使用参数, strong 和 weak
    @property(strong)Car *car;
    代表生成的私有属性_car 是1个强类型的
    @property(weak)Car *car;
    代表生成的私有属性_car 是1个弱类型的
    如果不写, 默认是strong.
 6. 使用建议.
    1). 在ARC机制下, 如果属性的类型是OC对象类型的. 绝大多数场景下使用strong
    2). 在ARC机制下, 如果属性的类型不是OC对象类型的. 使用assign
    3). strong和weak都是应用在属性的类型是OC对象的时候, 属性的类型不是OC对象的时候就使用assign
    在ARC机制下, 将MRC下的retain换为strong
 */
/*
 在ARC机制下, 当两个对象相互引用的时候, 如果两边都使用strong 那么就会内存泄露.
 解决方案: 1端使用strong 1端使用weak.
 */
/*
 1. 开发程序分为ARC和MRC:
    ARC编译器自己处理OC对象的引用和销毁
    MRC需要自动手动写retain, release, autorelease, dealloc等代码.
 2. 与多线程相关的参数. (线程安全锁)
    atomic: 默认值 安全, 但是效率低下.
    nonatomic: 不安全, 但是效率高.
    无论在ARC还是在MRC都可以使用.
    使用建议: 无论ARC还是MRC都使用nonatomic
 3. retain:
    只能用在MRC的模式下, 代表生成的setter方法是标准的内存管理代码.
    当属性的类型是OC对象的时候, 绝大多数情况下使用retain, 只有在出现了循环音容的时候1边retain, 1边assign
 4. assign:
    在ARC和MRC的模式下都可以使用assign.
    当属性的类型是非OC对象的时候 使用assign.
 5. strong:
    只能使用在ARC机制下, 当属性的类型是OC对象类型的时候, 绝大多数情况下使用strong
    只有出现了循环引用的时候, 1端strong 1端weak
 6. weak:
    只能使用在ARC机制下, 当属性的类型是OC对象的时候, 只有出现了循环引用的时候, 1端strong 1端weak
 7. readonly readwrite
    无论是ARC还是MRC都可以使用.
 8. setter getter 无论在ARC下还是在MRC下都可以改.
 在ARC机制下, 原来使用的retain的用strong
 出现循环引用的时候, MRC: 1边retain 1边assign ARC: 1边strong 1边weak
 */
/*
 1. 有可能会遇到的问题.
    程序使用的是ARC机制开发的, 但是其中的某些类使用的是MRC.
 2. 使用命令: -fno-objc-arc
 3. 可以将整个MRC程序, 转换为ARC程序.
 */
/*
 分类(category)
 如果1个类中有多个方法, 那么将这些方法都写在同1个类模块中, 当然是完全可以的, 但是这样会导致类过于臃肿, 后期难以维护和管理.
 默认情况下1个类占1个模块. 将所有成员都写在这1个模块中, 就很难管理,
 我们可以让1个类占多个模块, 将功能相似的方法定义在同1个模块中, 这样的好处是方便维护和管理.
 如何将1个类分为多个模块呢?
 1. 分类
    1). 顾名思义: 将1个类分为多个模块.
    2). 如何为1个类添加分类. 新建Objective-c file选category, 再选类名
    3). 会生成1个.h和1个.m的模块.
        模块的文件名: 本类名+分类名.h    本类名+分类名.m
    4). 添加的分类也分为声明和实现.
        @interface 本类名 (分类名)
        @end
        代表不是新创建1个类, 而是堆已有的类添加1个分类. 小括号中写上这个分类的名字.
        因为1个类可以添加多个分类, 为了区分每一个分类, 所以分类要取名字.
        @implementation 本类名 (分类名)
        @end
        这是分类的实现.
 2. 分类的使用
    1). 如果要访问分类中定义的成员, 就要把分类的头文件引进来.
 3. 分类的作用: 将1个类分为多个模块.
 4. 使用分类注意几个地方:
    1). 分类只能增加方法, 不能增加属性
    2). 在分类之中可以写@property 但是不会自动生成私有属性, 也不会自动生成getter setter的实现.
        只会生成getter setter的声明.
        使用 你就需要自己写getter和setter的声明, 也需要自己定义属性 这个属性就必须在本类中.
    3). 在分类的方法实现中不可以直接访问本类的私有属性(定义在本类的implementation之中).
        但是可以调用奔雷的getter setter来访问属性.
        本类的@property生成的私有属性, 只可以在本类的实现中访问.
        分类中不能直接访问私有属性 真.
        分类可以使用 getter setter 来访问.
        本类中的真私有属性在分类中无法直接访问.
    4). 分类中可以存在和本类同名方法的.
        当分类中有和本类中同名的方法的时候, 优先调用分类的方法, 哪怕没有引入分类的头文件.
        如果多个分类中有相同的方法, 优先调用最后编译的分类.
 ---------------
 什么时候需要使用分类:
 当1个类的方法很多很杂的时候, 当1个类很臃肿的时候, 那么这个时候我们就可以使用分类,
 将这个类分为多个模块, 将功能相似的方法写在同1个模块之中.
 */
 /*
 1. 分类的作用在于可以将我们写的类分为多个模块.
    可不可以为系统的类写1个分类呢?
    为系统自带的类写分类 这个就叫做非正式协议.
 2. 分类的第二个作用:
    为1个已经存在的类添加方法.
 3. NSString类都挺好的, 就是差了1个方法.
    统计字符串对象中有多少个阿拉伯数字.
  分类的作用:
  1). 将臃肿的类分为多个模块, 方便管理
  2). 扩展1个类.
 */
/*
 1. ARC机制垃圾回收机制的区别.
    GC: 程序在运行的期间, 有1个东西叫做垃圾回收器, 不断的扫描堆中的对象是否无人使用.只要没人使用,立即回收
    ARC: 不是运行时, 在编译的时候就会合适的地方插入retain, release, autorelease....
         插入的代码足以让对象无人使用的时候 引用计数器为0.
 2. 在构造方法中, 如果直接给属性赋值, 那么会绕过属性的setter方法, 导致对象没有正确的retain, 引用计数器数值不会+1,
    导致在release时会产生僵尸对象.
    正确的用法是使用self.属性 = 参数;的形式赋值, 这样会去调用属性的setter方法, 正确的retain.
 */
//自动释放池唯一的作用: 省略创建对象匹配的那个release.

 扩展1个类, 为1个类新增成员;
 1. 继承: 新创建1个类, 可扩展任意成员
 2. 分类: 没有新创建1个类, 看起来像修改本类, 分类只能增加方法.
 */
/*
 1. 延展 Extension
    1). 是1个特殊的分类, 所以延展也是类的一部分.
    2). 特殊之处:
        a. 延展这个特殊的分类没有名字
        b. 只有声明没有实现. 和本类共享1个实现.
 2. 延展的语法
    语法:
    @interface 本类名 ()
    @end
    没有实现, 和本类共享1个实现.
 3. 为类添加延展的步骤
    只有1个.h文件. 文件名称:本类名_取的文件名.h
    这个文件中只有延展的声明
    @interface Person ()
    @end
 4. 延展的基本使用.
    1). 延展的本质是1个分类, 作为本类的一部分.
        只不过是1个特殊的分类
        没有名字.
    2). 延展只有声明, 没有单独的实现. 和本类共享1个实现.
 5. 延展和分类的区别
    1). 分类有名字, 延展没有名字, 是1个匿名的分类.
    2). 每1个分类都有单独的声明和实现, 而延展只有声明 没有单独的实现 和本类共享1个实现.
    3). 分类中只能新增方法, 而延展中任意的成员都可以写.
    4). 分类中可以写@property 但是只会生成getter setter的声明.
        延展中写@property 会自动生成私有属性, 也会生成getter setter的声明和实现.
 6. 延展的应用场景.
    1). 要为类写1个私有@property
        生成getter setter方法只能在类的内部访问, 不能在外部访问.
        其实, 我们可以这样想: @property生成私有属性, 生成getter setter的实现, 不要声明.
    2). 延展100%的情况下不会独占1个文件, 都是将延展直接写在奔雷的实现文件中.
        这个时候, 写在延展中的成员, 就相当于是这个类的私有成员, 只能在奔雷的实现中访问.
        外部不能访问.
    3). 什么时候使用延展?
        当我们想要为类定义私有成员的时候, 就可以使用延展, 将延展定义在这个类的实现文件中.
        如果想要为类写1个真私有属性, 虽然我们可以定义在@implementation之中, 但是不要这么写 这样很不规范.
        写1个延展. 将这个私有属性定义在延展中.
        如果要为类写1个私有方法, 建议将声明写在延展中, 实现写在本类的实现中, 提高代码的阅读性
        如果想要为类写1个私有的@property 就直接写在延展就可以了.
    4). 延展天数就是来私有化类的成员的,
        如果类的成员只希望在类的内部访问, 那么就将其定义在延展中,
        如果类的成员允许被外界访问, 定义在本类的@interface中.
 */
/*
 1. OC在C的基础知识新增了一些数据类型, BOOL Boolean class nil SEL id block
 2. block是1个数据类型.
    int double float char ....
    既然是1个数据类型, 那么就可以声明这个数据类型的变量, 所以我们完全也可以声明1个block类型的变量.
    不同类型的变量中可以存储不同类型的数据.
    那么block类型的变量中可以存储什么样的数据呢?
    1). block是1个数据类型 所以我们可以声明1个block类型的变量.
    2). block类型的变量中专门存储1段代码, 这段代码可以有参数, 可以有返回值.
 3. block变量的声明
    1). 虽然block变量中是用来存储1段代码的, 但是1个block变量中并不是任意的1段代码都可以存进去的, 而是有限定的.
        也就是说, 在声明block变量的时候, 必须要指定这个block变量存储的代码段是否有参数, 是否有返回值.
        一旦指定以后, 这个block变量中就只能存储这样的代码了.
        声明了1个block变量, 返回值是void 参数是1个int类型的.
        这个时候, 这个block变量中就只能存储无返回值并且有1个int参数的代码段.
    2). 声明block变量的语法格式:
        返回值类型 (^block变量的名称)(参数列表);
        void (^myBlock1)(); 表示声明了1个block类型的变量叫做myBlock1 这个变量中只能存储没有返回值没有参数的代码段.
    3). 最重要的
        声明block变量的时候要指定这个block变量可以存储的代码段的返回值的参数描述.
        一旦指定, 这个block变量中就只能存储这样的代码段了, 其他格式的代码段无法存储.
 4. 初始化block变量
    1). 原理: 写1个符合block要求的代码段. 存储到block变量中就可以了.
    2). 代码段的书写格式:
        ^返回值类型(参数列表){
            代码段;
        };
    3). 写1个无参数无返回值的代码段.
        ^void(){
            NSLog(@"123");
        };
        这个时候, 我们就可以将这段代码使用赋值符号存储到 无返回值无参数要求的block变量中.
        也可以在声明block变量的同时使用符合要求的代码段初始化.
        void (^myBlock1)() = ^void (){
            NSLog(@"123");
        };
    4). 有返回值的代码段
        int (^myBlock2)() = ^int(){
            return 0;
        }
    5). 既有参数又有返回值的代码段.
        int(^myBlock3)(int num1, int num2) = ^int(int num1, int num2){
            return num1 +　num2;
        }
    6). 注意
        赋值给block变量的代码段必须要符合block变量的要求, 否则就会报错.
 5. 如何执行存储在block变量中的代码段.
    语法格式: block变量名();
    有参数就传参, 有返回值就接.
 6. 关于block的简写.
    1). 如果我们写的代码段没有返回值, 那么代码段的void可以省略.
        注意, 是代码段的返回值, 如果是void可以省略, 声明block变量的返回值无论是什么都不可以省略.
    2). 如果我们写的代码段没有参数, 那么代码段的小括号可以省略
        再次强调: 说的事代码段, 所以当1个代码段既没有参数, 也没有返回值的时候, 就只写^
    3). 声明block变量的时候, 如果有指定参数, 可以只写参数的类型而不写参数的名称;
        注意: 这个地方我们说的事声明block变量的时候 再写代码段的时候 类型和名称都要写.
    4). 无论代码段是否有返回值, 在写代码的时候, 可以不写返回值类型 省略.
        如果在写代码段的时候, 省略了返回值, 这个时候系统会自动的确定返回值的类型.
        如果代码段中么有返回任何数据 那么它会认为这个代码段时没有返回值的.
        如果代码中有返回数据, 返回的数据是什么类型 他就会认为这个代码段时什么类型的.
    建议: 仍然按照我们最标准的写法来写block变量和block代码段, 因为这样可以提高代码的阅读性.
 7. 简化block变量的复杂定义.
    1). 问题: 定义block变量的时候, 要写好大一串, 类型好长.
    2). typedef的使用场景, 将1个长类型定义为1个短类型.
    3). 我们也可以使用typedef将长的block类型 定义为1个短类型.
        typedef 返回值类型 (^新类型)(参数列表);
        typedef void (^NewType)(); 代表重新定义了1个类型叫做NewType 是1个block类型 无参数无返回值的block类型.
 8. 关于block块访问外部变量的问题
    1). 在block代码块的内部可以取定义在外部的变量的值, 定义在外部的局部变量和全局变量.
    2). 在block代码块的内部可以修改全局变量的值, 但是不能修改定义在外部的局部变量的值.
    3). 如果你希望我们定义的局部变量可以允许在block代码的内部去修改, 那么就为这个局部变量加1个__block的修饰符.
 -----总结-----
 1. block是1个数据类型
 2. block变量是来存储1段代码的.
 3. block变量的声明
 4. block变量的初始化
 5. 执行存储在block变量中的代码.
 6. 关于4个简写
 7. 使用typedef将赋值的block定义简化
 8. 访问外部变量的问题.
 */
/*
 1. block是1个数据类型, 能不能作为函数的参数呢? 当然是可以的.
 2. 如何为函数定义block类型的参数?
    a. 就是在小括号中声明1个指定格式的block变量就可以了.
    b. 可以使用typedef简化定义, 合约看起来就不会晕了.
 3. 如何调用带block参数的函数呢?
    a. 如果要调用的函数的参数是block类型的, 那么要求在调用的时候传入1个和形参block要求的代码段.
    b. 调用的时候, 可以先将代码段存储到1个block变量中, 然后再传递这个block变量.
        也可以直接将符合要求的代码段写在小括号中传递.
    c. 小技巧, 通过Xcode提示可以快速的生成block代码段的框架.
 4. 将block作为函数的参数可以实现什么样的效果?
    可以将调用者自己写的1段代码, 传递到函数内部去执行.
 5. block也可以作为函数的返回值.
    当将block作为函数的返回值的时候, 返回值的类型就必须要使用typedef定义的短类型.
 6. block与函数
    相同点: 都是封装1段代码
    不同点:
    1). block是1个数据类型, 函数是1个函数.
    2). 我们可以声明block类型的变量, 函数就只是函数.
    3). block可以作为函数的参数, 而函数不能直接作为函数的参数.(函数指针)
 */
/*
 什么时候block可以作为方法, 函数的参数?
 当方法的内部需要执行1个功能, 但是这个功能具体的实现 函数的内部不确定.
 那么这个时候, 就使用block让调用者将这个功能的具体实现传递进来.
 练习:
 写1个数组类, 给这个数组类提供1个方法 将1个国家字符串数组进行排序.
 函数内部:
    使用冒泡排序
    j j+1
    最开始的做法: 比较j和j+1这两个字符串, 我们直接比较的事字母顺序
    但是这么写的话就写死了
    想法:　比较这两个字符串的大小, 不要方法的内部自己写代码去比.
          因为不管写什么代码都是写死的.
    让调用者自己写1段代码来比较这两个资产的大小.
    这个地方需要执行调用者写的1段代码来比较j j+1的大小
    BOOL (^compareBlock)(char *country1, char *country2);
    写1个block来存储1段代码, 这段代码做的事情: 比较j j+1两个资产的大小, 返回结果.
    int res = compareBlock(countries[j], countries[j+1]);
 */
/*
 1. 协议: protocol
    作用:
    1). 专门用来声明一大堆方法. (不能声明属性, 也不能实现方法, 只能用来写方法的声明).
    2). 只要某个类遵守了这个协议, 就相当于拥有这个协议中的所有的方法声明. 而不用自己去定义.
 2. 协议的声明.
    @protocol 协议名称<NSObject>
    方法的声明:
    @end
    新建1个协议的方法. NewFile OC-File - protocol
    协议的文件名: .h 并且只有1个.h文件.
    在协议中, 只能用来声明方法, 协议的作用: 就是专门用来写方法声明的.
 3. 类遵守协议.
    协议就是用来写方法声明的, 就是用来被类遵守的.
    如果需要让1个类, 拥有协议中定义的所有的方法声明, 那么就让这个类遵守这个协议.
    类只要遵守1个协议, 那么这个类就拥有了这个协议中定义的所有的方法的声明了.
    @interface 类名: 父类名 <协议名称>
    @end
    : 表示继承
    <> 表示遵守的协议.
    当1个类, 遵守了1个协议, 那么就相当于这个类拥有了协议中定义的所有的方法的声明.
    这个类只是拥有了这个协议中的方法的声明而已, 没有实现, 所以 这个类, 就应该实现协议中的方法.
    如果类不实现协议中的方法, 其实也不会报错, 编译器只是会报警告.
    但是当创建对象, 来调用这个没有实现的协议中的方法的时候, 就会报错.
 4. 类是单继承, 但是协议可以多遵守.
    1个类只能有1个父类
    但是1个类可以同时遵守多个协议.
    @interface 类名 : 父类名 <协议名称1, 协议名称2...>
    @end
    当1个类遵守了多个协议之后, 就相当于这个类拥有了所有协议中定义的方法的声明.
    那么这个类, 就应该实现所有协议中的方法.
    如果不实现, 其实也不会报错, 编译器只是会报警告.
    但是当创建对象, 来调用这个没有实现的协议中的方法的时候, 就会报错.
    ------
    当1个类遵守了某个协议, 就相当于这个类拥有了这份协议中的所有的方法的声明.
    但是仅仅只是有方法的声明而已, 没有实现, 要类自己去实现.
    如果类不实现. 编译器不会报错, 只是给1个警告.
    当我们创建对象, 如果不调用这个协议方法, 就不会报错.
    如果不要用这个协议方法, 那就会报错.
 5. @required 与 @optional
    当1个类遵守了1分协议, 这个类就拥有这个协议中的所有方法的声明 仅仅是只有声明而已, 还要自己实现.
    如果不实现呢? 也不会报错, 只是给1个警告.
    @required 与 @optional 这两个修饰符是专门用来修饰协议中的方法的.
    在协议中, 如果方法的声明被@required修饰, 那么遵守这个协议的类必须要实现这个方法, 否则编译器会发出警告.
    在协议中, 如果方法的声明被@optional修饰, 那么遵守这个协议的类如果不实现这个方法, 编译器也不会报警告.
    其实, 无论是@required还是@optional你都可以不实现, 编译器是不会报错的. 仍然可以编译 运行.
    唯一的区别就是: 当遵守协议的类不实现协议中的方法的时候, @required会给1个警告, @optional警告都没有.
    这两个关键字的主要作用: 在于程序员沟通, 告诉遵守协议的类, 哪些方法是必须要实现的, 因为这些方法我会调用.
    默认的是@required
 6. 协议可以从梁歪1个协议继承, 并且可以多继承.
    协议可以继承另外1个协议, A 协议 继承了 B协议, 那么A协议中不仅有自己的方法的声明, 还有B协议中的方法的声明.
    如果有1个类遵守了A协议, 那么这个类就拥有了, A, B协议中的所有的方法的声明.
    协议之间继承的语法格式
    @protocol A协议名称 <B协议名称>
    @end
    代表A协议继承自B协议, A协议中既有自己的方法声明, 也有B协议中的方法声明.
    NSObject: 这是1个类, 是所有的OC类的基类, 这个类是苹果早就定义好的.
    NSObject: 这也是1个协议, 也是苹果早就定义好的. 这个协议被NSObject类遵守.
              所以 所有的OC对象都拥有这个协议中的所有方法.
              这个协议我们也叫做基协议.
    写协议的规范: 任何1个协议, 必须要简洁的或者直接的去遵守这个NSObject基协议.
    协议的名称可以和类的名称相同:
 7. @protocol类型限制.
    1). 要求某个指针保存的是遵守指定协议的对象.
        NSObject<myProtocol> *obj;
        id<myProtocol> *obj;
    2). 要求某个指针变量报错的事继承了某个类, 并遵守了指定协议的对象.
    3). 为什么要求对象遵守协议?
        因为要调用对象的这个方法 只有遵守了这个协议才有这个方法.
    4). 属性案例: 男孩子的女朋友.
    5). 协议与继承
        超人 鸟 飞机 装X飞.
 8. 案例: 婴儿饿了要哭, 困了要睡 保姆能照顾, 老师也能当保姆.
 */
/*
 1. 协议与协议之间可以相互继承.
    1). 继承的语法:
        @protocol 协议名称 <父协议名称>
        @end
    2). 效果:
        子协议中不仅有自己的方法的声明, 还有父协议中的所有的方法的声明.
        如果1个类遵守了某份协议, 那么这个类就拥有这个协议和这个协议的父协议中的所有的方法声明.
 2. 介绍NSObject
    在Foundation框架中, 有1个类, 叫做NSObject 是所有OC类的基类.
    在Foundation框架中, 有1个协议, 叫做NSObject
    NSObject协议被NSObject类遵守. 所以NSObject协议中的所有的方法, 全部的OC类都拥有了.
    这么说, 所有的OC类都遵守了NSObject协议, NSObject协议叫做基协议.
    类的名称可以和协议的名称一致.
 3. 写协议的规范:
    要求所有的协议都必须直接的或者间接的从NSObject基协议继承.
 */
/*
 1. 请声明1个指针, 这个指针可以指向任意的对象, 但是要求指向的对象要遵守指定的协议,
    如果不遵守 最起码要报1个警告.
    要求声明1个指针 指向1个遵守了学习协议的对象, 否则最起码要给1个警告.
    NSObject<协议名称> *指针名;
    这个时候, 这个指针可以指向遵守了指定协议的任意对象, 否则就会报1个警告.
    NSObject<StudyProtocol> *obj = [Student new];
    当然了完全可以使用id指针.
    id<协议名称> 指针名;
    id<StudyProtocol> id1 = [Student new];
 2. 声明1个指针变量, 要求这个指针变量指向的对象必须遵守多个协议.
    id<StudyProtocol,xStudyProtocol> id1 = [Student new];
 3. 定义1个指针, 指向遵守了学习协议的学生对象.
 4. why?
    1). 遵守了某个协议的类, 就相当于这个类拥有了这个协议所定义的行为.
    2). 只有类遵守了协议, 这个类中一定才会有协议方法.
 */

 1. 框架: 就是系统(苹果)或者第三方(其他的一些高手)事先写好了一些牛X功能的类.
         把这些类交给我们使用, 这些类的集合我们叫做框架.
         框架中有很多很多功能相似的类, 函数库
    Foundation框架: 是1个包 这里面有很多类, 函数, 定义了一些数据类型.
                   这个框架中的类都是一些最基础的类, NSString NSObject
                   其他的框架都是基于Foundation框架的.
    UIKit.
    AVFoundation.
    ......
 2. Foundation框架中最常用的类. 简单, 量大.
 3. NSString
    1). NSString是1个数据类型, 保存OC字符串的.
        NSString的本质是1个类, 既然是1个类,
        所以, 最标准的创建NSString对象的方式:
        NSString *str1 = [[NSString alloc] init];
        NSString *str2 = [NSString new];
        NSString *str3 = [NSString string];
        使用这种方式创建的字符串是1个空的字符. @""
        NSString对象就是用来存储字符串.
    2). NSString是OC中最常用的1个类了. 所以OC提供了一种更为快速创建字符串对象的方式.
        使用前缀@
        @"jack"; 本质上这是1个NSString对象. 这个NSString对象中存储的是"jack"这个字符串.
        NSString *str = @"rose";
        1). @"rose"本质上是1个NSString对象, 这个对象中存储的是字符串"rose".
        2). 将这个字符串对象的地址返回值给str1指针.
    格式控制符%p: 打印指针变量的值, 指向对象的指针值是地址.
            %@: 打印指针指向的对象.
 4. NSString的恒定性
    1). 当我们使用简要的创建字符串对象的时候, 也就是使用1个OC字符串常量来初始化字符串指针的时候,
        这个字符串对象是存储在 常量区(数据段)的.
        NSString *str = @"jack";
        当我们调用NSString的类方法来创建对象的时候.
        NSString *str = [NSString stringWithFormat:@"rose"];
        创建的字符串对象是存储在堆区.
    2). 当在内存中创建1个字符串对象以后, 这个字符串对象的内容就无法更改.
        当我们重新为字符串指针初始化值的时候, 并不是修改原来的字符串对象.
        而是重新的创建1个字符串对象, 将这个字符串对象的地址重新赋值给字符串指针变量.
    3). 当系统准备要在内存中创建字符串对象的时候, 会先检查内存中是否有相同内容的字符串对象.
        如果有, 直接指向, 如果没有才会重新创建.
    4). 存储在常量区的数据不会被回收, 所以存储在常量区的字符串对象也不会被回收.
 */
/*
 1. NSString是1个类, 那么肯定其中有很多的方法.
 2. 使用频率最高的几个方法.
    1). 使用拼接的方法创建1个NSString对象.
        + (instancetype)stringWithFormat:(NSString *)format, ...
    2). 得到字符串的长度.
        @property (readonly) NSUInteger length;
    3). 得到字符串中指定下标的字符.
        - (unichar)characterAtIndex:(NSUInteger)index;
        返回值是unichar类型的, 要打印的话使用%C
    4). 判断两个字符串的内容是否相同.
        a. 能否使用 == 来判断两个OC字符串的内容是否相同.
        b. == 运算符的作用: 比较左右两边的数据是否相同.
           -> 10 == 10 这个时候直接比较的事左右两边的数据是否相同.
           -> a == b 两边也可以写1个变量, 这个时候比较的是左右两边的变量的值是否相同.
           -> 如果两边是1个指针变量, 那么比较的也是变量的值, 只不过指针变量的值是地址.
        c. 所以. 如果我们要比较两个OC字符串的内容是否相同, 不能使用 == 去比较.
           因为 == 比较的是字符串指针变量的值, 而我们要比的事两个字符串指针指向的字符串对象的内容是否相同.
        d. 调用方法:
           - (BOOL)isEqualToString:(NSString *)aString;
           就可以比较当前字符串对象和闯入的字符串对象的内容是否相同.
    5). 将C语言的字符串转换为OC字符串对象.
        + (nullable instancetype)stringWithUTF8String:(const char *)nullTerminatedCString
    6). 将OC字符串对象转换为C语言的字符串.
        @property (nullable, readonly) const char *UTF8String
 */
/*
 1. 将字符串内容写入到磁盘上的某1个文件之中.
    - (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error;
    参数1: 将字符串内容写入到哪1个文件之中, 写上文件的路径.
    参数2: YES, 先将内容写入到1个临时文件, 如果成功再将这个文件搬到指定的目录.
          安全,效率较低.
          NO, 直接将内容写入到指定的文件, 不安全, 效率高.
          推荐使用NO
    参数3: 指定写入的时候使用的编码, 一般情况下这里写 NSUTF8StringEncoding
          使用UTF-8编码.
    参数4: 二级指针, 要传递1个NSError指针的地址.
          如果写入成功, 这个指针的值就是nil
          如果写入失败, 这个指针就会指向1个错误对象, 这个对象描述了发送错误的信息.
          这个对象的localizedDescription方法可以得到发生错误的简要信息.
          所以我们要判断是否写入成功, 也可以判断这个指针的值是否为nil
          如果不想知道发生错误的原因, 那么第4个参数给nil就可以了.
    返回值是BOOL类型的, 代表是否写入成功.
 2. 从磁盘上的文件中读取文件中的内容.
    + (nulltable instancetype)stringWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error;
    第1个参数: 文件的路径
    第2个参数: 使用的编码. NSUTF8StringEncoding
    第3个参数: 错误对象
    nullable 代表返回的对象有可能是nil
 3. 使用URL来读写字符串数据(资源)
    1). 优势: 既可以读写本地磁盘文件.
             还可以读写网页文件\ftp服务器上的文件.
        NSURL对象, 专门用来保存资源地址的, 资源地址: 本地磁盘路径, 网页地址, ftp文件地址.
    2). 不同的类型的URL地址的写法. 资源路径的地址的写法.
        1). 本地磁盘文件: file:///Users/xxx/Desktop/1.txt  -->http:// 开头的是网页路径的写法
        2). 网页地址: http://www.baidu.com/index.html  -->File:// 开头的事本地磁盘的路径
        3). ftp文件的地址: ftp://server.itcast.cn/1.txt  -->ftp:// 开头的事ftp文件资源的路径
        如果要将1个资源路径的地址保存到NSURL对象中, 地址一定要是标准写法.
    3). 将不同类型的地址封装在NSURL对象之中. 如何将资源地址存储到NSURL对象中.
        NSURL *u1 = [NSURL URLWithString:@"file:///Users/xxx/Desktop/1.txt"];
 
        [str writeToURL:u1 atomically:NO encoding:NSUTF8StringEncoding error:nil];
        [NSString stringWithContentsOfURL:u1 encoding:NSUTF8StringEncoding error:nil];
    4). 字符串提供了对应的方法去读写NSURL对象中封装的资源路径
        从指定资源路径读取文本内容.
        + (nullable instancetype)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error;
        将字符串的内容写入到资源路径中.
        - (BOOL)writeToURL:(NSURL *)url atomically:(BOOL)atomically encoding:(NSStringEncoding)enc error:(NSError **)error;
        如果要向网页或者ftp写内容要有权限.
 4. 字符串比较
    - (NSComparisonResult)compare:(NSString *)string;
 5. 字符串比较:忽略大小写的比较:
    - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;
    NSCaseInsensitiveSearch
    NSNumericSearch
 6. 字符串的相等判断.
 7. 判断字符串是否以指定的字符串开头
    - (BOOL)hasPrefix:(NSString *)str;
 8. 判断字符串是否以指定的字符串结尾
    - (BOOL)hasSuffix:(NSString *)str;
 9. 主串中搜索子串. 从前往后
    - (NSRang)rangeOfString:(NSString *)searchString;
    返回值是1个NSRange类型的结构体变量.
    typedef struct _NSRange {
        NSUInteger location; 代表子串在主串出现的下标.
        NSUInteger length; 代表子串在主串中匹配的长度.
    }NSRange;
    如果没有找到:
    location 为NSUInteger的最大值. 也就是NSNotFound
    length 的值为0
    这个方法, 是从前往后搜索, 第1次匹配的子串.
 10. 主串中搜索子串. 从后往前
     - (NSRang)rangeOfString:(NSString *)searchString options:(NSStringCompareOptions)mask;
 11. NSRange结构体
     1). 是Foundation框架中定义的1个结构体.
     typedef struct _NSRange {
         NSUInteger location;
         NSUInteger length;
     }NSRange;
     NSRange range;
     这个结构体变量一般情况下用来表示1段范围. 特别用在子串在主串中的范围表示.
     NSRange range = {4, 4};
     2). 声明并初始化结构体变量的方式.
         1). 最原始的方式.
             NSRange range;
             range.location = 3;
             range.length = 4;
         2). 第二种方式: NSRange range = {3, 7};
         3). 第三种方式: NSRange range = {.location = 3, .length = 7};
         4). Foundation框架中定义了1个函数. 这个函数可以快速的创建1个NSRange结构体.
             NSRange range = NSMakeRange(loc, len);
             返回1个指定属性的NSRange结构体变量.
         5). Foundation框架中定义了1个函数, 可以将1个NSRange结构体变量转换为NSString
             NSStringFromRange(ran) 函数可以将NSRange结构体变量转换为指定格式的字符串.
 */
/*
 1. 字符串的截取
    取到字符串的1部分
     - (NSString *)substringFromIndex:(NSUInteger)from; 从指定的下标处一直截取到最后.
     - (NSString *)substringToIndex:(NSUInteger)to; 从第0个开始截取指定的个数.
     - (NSString *)substringWithRange:(NSRange)range; 截取指定的1段范围.
 2. 字符串的替换
    - (NSString *)stringByReplacingOccurrencesOfString:(NSString *)target withString:(NSString *)replacement
    将字符串中第1个参数替换为第2个参数, 提示: 原来的指针指向字符串的内容是不会变的
    新串是以方法的返回值返回的. 会全部替换.
    这个方法还可以做删除, 原理: 将其替换为@""
 3. 字符串数据转换为其他的类型, 使用频率很高.
     @property (readonly) double doubleValue;
     @property (readonly) float floatValue;
     @property (readonly) int intValue;
     @property (readonly) NSInteger integerValue;
     @property (readonly) long long longLongValue;
     @property (readonly) BOOL boolValue;
     转换注意, 从头开始转换, 能转换多少就是多少.当遇到不能转换的时候就停止转换.
 4. 去掉字符串前后的空格.
    str = [str stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
    中间的空格无法去掉.
 5. 转大写, 转小写
     @property (readonly, copy) NSString *uppercaseString;
     @property (readonly, copy) NSString *lowercaseString;
 6. 去掉字符串前后的小写字母
    stringByTrimmingCharactersInSet:[NSCharacterSet lowercaseLetterCharacterSet]
 7. 去掉字符串前后的大写字母
    uppercaseLetterCharacterSet
 8. 去掉头尾指定的字符串
    characterSetWithCharactersInString:@"xxx";
 */
/*
 1. 字符串的恒定性
    一旦创建1个字符串对象, 那么这个字符串对象的内容就无法更改, 当我们修改字符串的时候, 其实是重新的创建了1个字符串对象.
    代码案例:
    循环创建50000个不同的字符串, 会耗费很长的时间, 每次循环的时候, 都会创建1个新的字符串对象. 因为字符串的恒定性.
 2. 如何让这样的大批量的字符串拼接可以更加快速一点.
    1). 慢的原因: 因为字符串的恒定性, 每次修改字符串的时候, 是重新的创建1个对象.
    2). 希望: 有没有一种对象是用来存储字符串的, 并且存储在这个对象中的字符串数据可以更改.
 3. NSMutableString
    1). 是Foundation框架中的1个类, 从NSString继承.
        所以NSMutableString对象是用来存储字符串数据的.
    2). NSMutableString在父类NSString的基础之上做的扩展.
        存储在NSMutableString对象中的字符串数据可以更改, 具备可变性.
        直接可以改存储在NSMutableString对象中的字符串数据, 不会新创建对象.
 4. NSMutableString的用法
    1). 既然是1个类, 要使用的话, 就的创建1个对象.
        NSMutableString *str = [NSMutableString string];
    2). 往可变字符串对象中追加字符串.
     - (void)appendString:(NSString *)aString;  直接追加内容
     - (void)appendFormat:(NSString *)format    以拼接的方式往可变字符串对象中追加内容.
    3). 创建NSMutableString对象的时候, 记住下面这样的初始化方式是不行的.
        NSMutableString *s = @"j";
        @"j" 是1个NSString对象, 是1个父类对象.
        而s指针是1个NSMutableString类型的 是1个子类类型的.
        如果通过子类指针去调用子类独有的成员 就会运行错误.
    4). NSMutableString从NSString继承
        在使用NSString的地方完全可以使用NSMutableString
 5. 使用NSMutableString来做大批量的字符串拼接.
    这个时候"biu"的一下就结束了, 为什么这么快? 因为NSMutableString只有1个, 每次修改的时候 直接修改的事这个对象中的数据.
 6. 使用建议:
    1). 我们平时使用的时候, 还是使用NSString, 因为效率高.
    2). NSMutableString: 只在做大批量的字符串拼接的时候才使用.
        大批量拼接的时候, 就不要去使用NSString 因为效率低下
 */
/*
 1. 回忆C语音的数组
    特点:
    a. 存储多个数据
    b. 类型相同
    c. 长度固定
    d. 每1个元素都是紧密相连的.
 2. NSArray
    1). 是Foundation框架中的一个类, 这个类的对象是来存储多个数据的, 具备数组的功能.
        所以NSArray是OC中的数组
    2). 特点:
        a. 只能存储OC对象, 任意的OC对象. 无法存储非OC对象的数据.
        b. 长度固定, 一旦NSArray数组创建完毕之后, 元素的长度固定, 无法新增, 无法删除元素.
        c. 每2个元素都是紧密相连的, 每1个元素仍然有自己的下标.
        d. 元素的类型是id类型的.
 3. NSArray数组的创建.
    1). 因为这是1个类, 所以当然就是创建NSArray对象.
        NSArray *a1 = [NSArray new];
        NSArray *a1 = [[NSArray alloc] init];
        NSArray *a1 = [NSArray array];
        这样创建出来的NSArray数组的元素的个数是0个, 因为长度固定, 所以没有任何意义.
    2). 创建数组的同时指定1个数组的元素.
        NSArray *a1 = [NSArray arrayWithObject:@"Jack"];
        仍然没有意义, 因为这个数组中只有1个元素.
    3). 最常用的创建NSArray数组的方式.
        NSArray *a1 = [NSArray arrayWithObjects:@"Jack",@"Jack",nil];
        使用注意:
        1). 只能存储OC对象, 不能存储非OC对象.
        2). 将元素写完以后, 最后要写1个nil, 表示元素到此结束了.
    4). 创建NSArray数组的简要方式.
        NSArray *a1 = @[写上每1个元素的值用逗号分隔];
        NSArray *a1 = @[@"Jack", @"rose"];
        注意: 这种创建方式 不需要在最后加nil
 4. NSArray数组的使用.
    1). 在NSLog函数中使用%@可以直接输出NSArray对象中的所有的元素的值.
    2). NSArray数组中不能存储基本数据类型, 不能存储非OC对象.
        nil的本质其实就是0 所以nil无法存储到NSArray数组中.
    3). 使用new, alloc, init, array方法创建数组没有任何意义.
        这些数组是没有元素的, 而NSArray数组元素无法新增和删除, 所以没有任何意义.
 5. 取出存储在NSArray数组中的元素的值.
    1). 可以使用小白去除对应的元素的值. arr[0]
        如果下标越界 就直接运行报错.
    2). 调用数组对象的对象方法来取出指定下标的元素的值.
        [arr objectAtIndex:1];
 6. NSArray数组的其他的常用方法.
    1). 得到NSArray数组中的元素的个数.
        @property (readonly) NSUInteger count;
    2). 判断NSArray数组中是否包含指定的元素.
        - (BOOL)containsObject:(ObjectType)anObject;
    3). 取到NSArray数组中的第1个元素.
        @property (nullable, nonatomic, readonly) ObjectType firstObject;
        与arr[0]的区别.
        如果数组中没有任何元素, arr[0]报错. firstObject取到nil 不报错.
    4). 取到NSArray数组中的最后1个元素.
        @property (nullable, nonatomic, readonly) ObjectType lastObject;
    5). 查找指定的元素在NSArray数组中第一次出现的下标.
        - (NSUInteger)indexOfObject:(ObjectType)anObject;
        如果没有找到, 返回的是NSUInteger的最大值. NSNotFound
 7. NSArray数组的遍历.
    1). 使用for循环来遍历数组中的每1个元素.
        原理: 将下标价格挨个遍历出来 取值.
    2). 使用增强for循环来遍历NSArray数组中的元素.
        a. 语法格式:
           for(元素类型 变量名 in 数组名){直接通过变量名就可以拿到数组中的每1个元素.}
        b. 声明在for()中的变量叫做迭代变量.
        c. 执行原理
           将数组中的第1个元素的值赋值给迭代变量, 执行循环体. 以此类推...结束循环.
        d. 语法总结:
           -> 迭代变量的类型和数组中的元素的类型保持一致.
           -> 迭代变量的名称可以任意取, 根据自己的爱好.
           -> in是固定的.
           -> 遍历那1个数组, 就将数组写在in后面.
           -> 循环体里面, 迭代变量的值就是元素的值.
        当NSArray数组中存储的数据的类型不一致时候, 迭代变量的类型建议使用id类型.
    3). 使用block遍历
        - (void)enumerateObjectsUsingBlock:(void (NS_NOESCAPE ^)(ObjectType obj, NSUInteger idx, BOOL *stop))block
        这是1个方法, 这个方法的作用就是来遍历数组中的每1个元素.
        这个方法做的事情: 将arr数组中的每1个元素遍历出来.
        当它将每1个元素遍历出来以后, 如何处理遍历出来的元素呢?
        所以要求我们传递1段处理元素的代码过去.
        如果想停止遍历, 就将stop指针指向的BOOL变量的值改为YES
 8. NSArray与字符串的两个方法.
    1). 将数组中的元素链接起来组成1个新的字符串.
        - (NSString *)componentsJoinedByString:(NSString *)separator;
        参数: 连接符.
    2). 将字符串以指定的分隔符分成1个数组, 每1部分就是数组的1个元素.
        - (NSArray<NSString *> *)componentsSeparatedByString:(NSString *)separator;
 */
/*
 1. NSMutableArray是NSArray的子类.
    1). NSMutableArray仍然是1个数组, 具备NSArray数组的特点.
        只能存储OC对象, 每1个元素的紧密相连的.
    2). NSMutableArray相对于父类做的扩展:NSMutableArray数组的元素可以动态的新增和删除.
        其他的用法均与NSArray一致.
        所以: NSArray数组一旦创建, 其元素的个数就固定, 无法新增删除.
             NSMutableArray数组, 元素可以新增, 可以删除. 其他用法和父类一样.
 2. NSMutableArray数组的创建.
    NSMutableArray *a = [NSMutableArray new];
    NSMutableArray *a = [NSMutableArray array];
    NSMutableArray *a = [[NSMutableArray alloc] init];
    这样创建出来的数组对象, 数组的元素是0, 仍然是有意义的, 因为我们可以动态的新增和删除元素.
    也可以使用这样的方式来创建可变数组对象, 这个数组的元素可以新增和删除.
    NSMutableArray *a = [NSMutableArray arrayWithObjects:@"jack",@"rose",nil];
    最容易犯错: 这样写是不可以的.
    NSMutableArray *a = @[@"NSMutableArray", @"new"]; 这是1个NSArray对象.
    a是1个子类指针, 子类指针指向父类对象的就有可能会出问题.
 --------
 1. 任意的指针其实可以指向任意的对象, 编译不会报错 只会给1个警告.
 2. 虽然语法上可以乱指, 但是千万别这么做, 因为运行的时候可能出错.
    当我们调用指针类型特有的方法的时候.
 --------
 3. 如何往可变数组中新增元素.
    - (void)addObject:(ObjectType)anObject;
    将传入的参数作为数组的元素添加进去.
 4. 将另外1个数组中的每1个元素添加到可变数组中.
    - (void)addObjectsFromArray:(NSArray<ObjectType> *)otherArray;
 5. 在可变数组中指定的下标出插入1个元素.
    - (void)insertObject:(ObjectType)anObject atIndex:(NSUInteger)index;
 6. 删除可变数组中指定下标的元素
    - (void)removeObjectAtIndex:(NSUInteger)index;
 7. 删除可变数组中所有的指定的元素
    - (void)removeObject:(ObjectType)anObject;
 8. 删除指定范围中的所有指定元素.
    - (void)removeObject:(ObjectType)anObject inRange:(NSRange)range;
 9. 删除最后1个元素
    - (void)removeLastObject;
 10.删除所有元素
    - (void)removeAllObjects;
 */
/*
 1. 无论是NSArray还是NSMutableArray里面都只能存储OC对象.
    基本数据类型是无法存储的.
 2. 如何将基本数据类型的数据存储到NSArray数组中.
 3. 自定义包装类来包装基本数据类型.
    定义1个类, 这个类的对象的作用是用来存储1个int类型的数据, 再将这个对象存储到NSArray数组中.
 4. NSNumber是Foundation框架中定义好的1个类, 这个类的对象的作用就是用来包装基本数据类型的.
    将基本数据类型存储到NSArray数组中的步骤.
    1). 先将基本数据类型包装到NSNumber对象中,
    2). 再将NSNumber对象存储到NSArray数组中.
 5. 简写方式
    创建NSNumber对象的简写方式:
    @10; 代表是1个NSNumber对象, 这个对象中包装的是整形的10
         这个不是整形的10, 是用NSObject包装的对象, 其中intValue属性值为10. 所以在获取值的时候要用.intValue
    NSNumber *num = [NSNumber numberWithInt:10];
    num.intValue;
    包装注意:
    如果后面的数据是1个变量, 那么这个变量就必须要使用小括号括起来.
    int num = 10;
    @(num);
 */
/*
 1. 将数组的信息(数组的元素的值)保存起来, 保存在磁盘上.
    数据的持久化
 2. plist文件. 属性列表文件.
    这个文件可以保存数组, 把数组中的元素保存在这个文件中.
 3. 原理:
    1). 将数组的信息存储到plist文件中, 就会将数组的所有的元素存储到这个文件中.
        -(BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
    2). 将plist文件中的数据还原为1个数组.
        +(nullable NSArray<ObjectType> *)arrayWithContentsOfFile:(NSString *)path;
 */
/*
 1. NSArray与NSMutableArray是OC中的数组.
    存储数据的特点: 每1个元素紧密相连. 并且每1个元素中都是直接存储的值.
    缺点: 数组元素的下标不固定, 都有可能会发生变化. 无法通过下标来唯一确定数组中的元素.
    希望: 有一种存储数据的方式 存储到数组中, 可以快速唯一的确定数组的元素.
    存储数据的时候, 必须要为存储的数据取1个别名.
    这个别名的作用: 就是用来确定别名对应的数据的.
    要找存储在数组中的数据, 使用别名来找 而不是通过下标来找 因为下标有可能会发生变化.
    这种存储数据的方式就叫做 键值对 的存储方式.
    Key-Value
    Key 就是键 就是为数据取得别名.
    Value 就是值 就是真正存储的数据.
 2. NSDictionary 与 NSMutableDictionary
    1). 他们是数组. 他们就是以键值对的形式存储数据的.
        往这个数组中存储数据的同时, 必须要指定这个数据的别名才可以.
        要找到存储在这个数组中的数据, 通过别名来找, 而不是通过下标.
 3. NSDictionary 字典数组
    1). 存储数据的原理.
        a. 以键值对的形式存储数据.
        b. 字典数组一旦创建, 其中的元素就无法动态的新增和删除.
        c. 键: 只能是遵守了NSCoping协议的对象, 而NSString就是遵守了这个协议.
           值: 只能是OC对象.
    2). 创建字典数组
        NSDictionary *dict1 = [NSDictionary new];
        NSDictionary *dict2 = [NSDictionary dictionary];
        NSDictionary *dict3 = [[NSDictionary alloc] init];
        这种方式创建出来的字典数组中没有任何元素. 所以没有意义.
    3). 一般创建方式
        + (instancetype)dictionaryWithObjectsAndKeys:(id)firstObject, ...
        将字典数组的值键 挨个的写在后面初始化.
        NSDictionary *dict4 = [NSDictionary dictionaryWithObjectsAndKeys:@"jack",@"name",@"北京",@"city", nil];
    4). 简要创建方式.
        @{键0:值0,键1:值1,键2:值2,键3:值3,....};
 4. 使用字典数组
    1). 如何取出存储在字典数组中的数据.
        a. 存储在字典数组中的元素不能使用下标去取 而是用键 也就是别名去取.
        -> 使用中括号的方式.
           字典数组名[键]; 这样就可以取到字典数组中这个键对应的值.
           dict[@"name"]; 取出dict字典数组中@"name"这个键对应的值.
        -> 调用自动数组对象的方法也可以取出键对应的值.
           -(nullable ObjectType)objectForKey:(KeyType)aKey;
        如果给定的key在数组中不存在, 取到的值是nil 不会报错.
    2). 取到字典数组的键值对的个数.
        @property(readonly)NSUInteger count;
    3). 往字典数组中存储键值对的时候, 键不允许重复.
        如果键重复: 后加的无效...
 5. 遍历字典数组
    1). 字典数组中的数据无法使用下标去取 所以普通的for循环遍历下标法就无用武之地了.
    2). 使用for in循环, 遍历出来的是字典数组中所有的键. 再通过键取出对应的值.
    3). 使用block遍历.
        - (void)enumerateKeysAndObjectsUsingBlock:(void (NS_NOESCAPE ^)(KeyType key, ObjectType obj, BOOL *stop))block
 6. 字典数组存储数据的原理.
    1). 当往字典数组中存储1个键值对的时候, 这个键值对应该存储在下标为几的元素中呢?
        -> 并不是按照顺序挨个挨个的存储的.
        -> 存储键值对的时候, 会根据键和数组的长度做1个哈希算法. 算出1个下标, 将这个键值对存储在该下标处.
    2). 取值的时候:
        也是根据键做1个哈希算法, 就可以算出这个键值对存储的下标 然后直接找到这个下标的数据取出就可以了.
    与NSArray对比
    1). NSArray数组的元素. 挨个挨个的最后面, 按照顺序来存储的.
        字典数组中不是挨个挨个的存储的, 存储的下标是算出来的.
    2). 存的效率: 肯定是NSArray要高一些.
        取得时候: 如果取值的时候, 是全部取出来, 这个时候NSArray快一些.
                 如果取值的时候, 只会取数组中指定的几个元素, 字典数组取值更快一些.
 什么时候使用NSArray 什么时候使用字典数组?
 存储进去之后, 一旦要取值, 就是全部取出, NSArray
 存储进去之后, 取值只会取指定的几个元素, 字典数组.
 1. NSMutableDictionary
    1). 是NSDictionary的子类, 所以NSMutableDictionary也是1个字典数组, 也是以键值对的形式存储数据的.
    2). 重点: NSMutableDictionary在父类基础之上做的扩展:
        存储在其中的元素可以动态的新增和删除.
    3). 创建可变字典数组.
         NSMutableDictionary *dict1 = [NSMutableDictionary new];
         NSMutableDictionary *dict2 = [NSMutableDictionary dictionary];
         NSMutableDictionary *dict3 = [[NSMutableDictionary alloc] init];
         这样创建出来的可变字典数组的长度为0 但是有意义 因为可以动态的新增和删除.
        NSMutableDictionary *dict3 = [NSMutableDictionary  dictionaryWithObjectsAndKeys:@"jack",@"name",@"北京",@"city", nil];
        在创建可变数组的同时初始化键值对.
        注意: NSMutableDictionary *dict3 = @{}; 这样是不行的,
 2. 如何新增键值对.
    -(void)setObject:(ObjectType)anObject forKey:(KeyType <NSCopying>)aKey;
    如果键重复, 后添加的就会替换原有的.
 3. 如何删除.
    -(void)removeAllObjects; 删除所有的键值对.
    -(void)removeAllObjectForKey:(KeyType)aKey; 删除指定的键值对.
 4. 也可以将字典数组的信息持久化起来.
    将字典数组的信息报错到plist文件中.
    -(BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile;
    从plist文件中还原回字典.
    +(nullable NSDictionary<KeyType, ObjectType> *)dictionaryWithContentsOfFile:(NSString *)path;
 */
/*
 1. 集合
    NSArray集合, NSDictionary字典集合, 就叫做集合.
 2. 在MRC的模式下, 将1个对象存储到集合中, 会不会影响对象的引用计数器
    将对象存储到集合之中, 会为这个对象的引用计数器+1
    当集合销毁的时候, 就会像存储在集合中的所有的对象发送1条release消息.
 3. 使用@[]或者@{}创建的集合已经被autorelease过的了.
    直接调用和类同名的类方法创建的对象 也是被autorelease过的了.
 4. 在ARC的模式下, 集合的元素是1个强类型的指针.
 */
/*
 1. NSFileManger是Foundation框架提供的1个类.
    这个类作用: 用来操作磁盘上的文件 文件夹 对他们进行创建, 删除, 复制, 拷贝, 移动....
 2. NSFileManger是1个类.
    这个类的对象是以单例模式创建的.
    如何得到NSFileManger的1个单例对象.
    调用这个类的类方法, defaultManager 就可以得到这个类的单例对象
    NSFileManger *fileManager = [NSFileManger defaultManager];
 3. 常用方法之 判断
    1). 判断指定的文件或者文件夹在磁盘上是否真实存在.
        -(BOOL)fileExistsAtPath:(NSString *)path;
    2). 判断指定的路径是否真实的存储在我们的磁盘之上, 并且判断这个路径是1个文件夹路径还是1个文件路径.
        -(BOOL)fileExistsAtPath:(NSString *)path isDirectory:(BOOL *)isDirectory;
        返回值: 代表这个路径是否真实存在.
        参数指针: 代表这个路径是否是1个文件夹路径. YES文件夹, NO文件
    3). 判断指定的文件或者文件是否可以读取.
        -(BOOL)isReadableFileAtPath:(NSString *)path;
    4). 判断指定的文件或者文件是否可以写入.
        -(BOOL)isWritableFileAtPath:(NSString *)path;
    5). 判断指定的文件或者文件是否可以删除.
        -(BOOL)isDeletableFileAtPath:(NSString *)path;
 4. 常见方法之 获取信息.
    1). 获取指定文件或者文件夹的属性信息.
        -(NSDictionary *)attributesOfItemAtPath:(NSString *)path error:(NSError **)error
        返回的是1个字典, 如果要拿到特定的信息 通过key
    2). 获取指定目录下的所有的文件和目录, 是拿到指定目录下的所有的文件和目录 所有的后代目录和文件.
        子目录->子目录->子目录 所有的都可以拿到.
        -(NSArray *)subpathsAtPath:(NSString *)path;
    3). 获取指定目录下的所有的子目录和文件, 不包括孙子辈.
        -(NSArray *)contentsOfDirectoryAtPath:(NSString *)path error:(NSError **)error
 5. 常见方法之 文件/目录的创建
    1). 在指定的目录创建文件.
        -(BOOL)createFileAtPath:(NSString *)path contents:(NSData *)data attributes:(NSDictionary *)attr
        第1个参数: 要创建的文件的路径.
        第2个参数: 这个文件的内容. 要传递这个文件的二进制格式.
                  这个二进制的数据格式 使用NSData对象来封装.
                  NSData: 将别的格式的数据转换为二进制数据.
                  将字符串转换为NSData二进制的方式, 调用字符串对象的
                  -(NSData *)dataUsingEncoding:(NSStringEncoding)encoding
                 编码参数: NSUTF8StringEncoding
                 指定1个编码 就可以将字符串转换为二进制数据 存储在NSData对象之中.
                 最后再将这个二进制对象通过这个方法写入.
                 如果想创建1个空文件 第2个参数就给nil
        第3个参数: 指定创建的文件的属性, 如果想要使用系统的默认值使用nil
    2). 在指定的目录创建文件夹.
        -(BOOL)createDirectoryAtPath:(NSString *)path withIntermediateDirectories:(BOOL)createIntermediatesattributes:(NSDictionary *)attributes error:(NSError **)error
        第1个参数: 路径.
        第2个参数: YES, 做一路创建, 如果是NO就不会做一路创建.
        第3个参数: 指定属性 nil为系统默认属性.
        第4个参数.
    3). 拷贝文件
        -(BOOL)copyItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
    4). 移动文件 剪切 文件的重命名. 重命名的原理: 将文件移动到原来的目录并改名.
        -(BOOL)moveItemAtPath:(NSString *)srcPath toPath:(NSString *)dstPath error:(NSError **)error
    5). 删除文件
        -(BOOL)removeItemAtPath:(NSString *)path error:(NSError **)error
    注意 删除的文件不会倒废纸篓 而是直接删除, 所以请小心使用.
 */
/*
 常用结构体
 1. 定义1个变量来保存按钮在iOS界面上的位置.
    我们定义1个结构体来表示控件在界面上的坐标.
    typedef struct{
        int x; int y;
    }CZPoint;
    CZPoint p1 = {20, 30};
    在Foundation框架中, 已经定义了1个结构体CGPoint.
    struct CGPonit{
        CGFloat x; CGFloat y;
    };
    typedef struct CGPoint CGPoint;
    CGFloat类型的实际上就是1个double类型的.
    这个结构体一般情况下是用来表示坐标的, 用来表示控件在界面上的位置.
    CGPoint与NSPoint都是同1个结构体, 只不过定义两个名字.
    typedef CGPoint NSPoint;
 -----------声明CGPoint变量并初始化的方式------------------
 1). CGPoint p1;
    p1.x = 20;
    p1.y = 30;
 2). CGPoint p1 = {20, 30};
 3). CGPoint p1 = {.x = 20, .y = 30};
 4). Foundation框架中提供的函数来快速的创建1个CGPoint变量.
     a. CGPointMake(x, y);
        CGPoint p1 = CGPointMake(20, 30);
     b. NSMakePoint(x, y);
        NSPonit p2 = NSMakePoint(20, 30);
 2. 声明1个变量来保存某个控件的大小.
    1个控件的大小, 无非就是两个数据. 宽度. 高度.
    typedef struct{
        double x; double y;
    }CZSize;
    CZSize size = {50, 20};
    Foundation框架中已经定义好了1个结构体叫做CGSize;
    struct CGSize{
        CGFloat width; CGFloat height;
    };
    typedef struct CGSize CGSize;
    typedef CGSize NSSize;
    CGSize和NSSize是同1个结构体, 只不过定义类两个名称.
    CGSize结构体一般情况下用来表示控件的大小.
 -------CGSize声明并初始化的方式-----------
 1). CGSize size;
 size.width = 20;
 size.height = 30;
 2). CGSize size = {20, 30};
 3). CGSize size = {.width = 20, .height = 30};
 4). Foundation框架中提供的函数来快速的创建1个CGPoint变量.
     a. CGSizeMake(width, height);
        CGSize size1 = CGSizeMake(20, 30);
     b. NSMakeSize(width, height);
        NSSize size2 = NSMakeSize(20, 30);
 3. CGRect和NSRect
    这是定义在Foundation框架中的1个结构体.
    struct CGRect {
        CGPoint origin;
        CGSize size;
    };
    typedef struct CGRect CGRect;
    所以 这个结构体变量一般情况下存储1个控件的位置和大小.
    typedef CGRect NSRect;
    NSRect和CGRect 是一样的.
 -------CGRect的声明和初始化---------
 1. CGRect rect;
    rect.origin.x = 10;
    rect.origin.y = 20;
    rect.size.width = 100;
    rect.size.height = 100;
    当结构体作为另外1个结构体或者对象的1个属性的时候, 不能直接{}赋值.
    CGRect rect;
    rect.origin = (CGPoint){10, 20};
    rect.size = (CGSize){10, 20};
 2. 也提供了函数来快速的创建CGRect变量.
    CGRect rect = CGRectMake(10, 20, 100, 30);
    CGRect rect = NSMakeRect(10, 20, 100, 30);
 使用的时候. CGSize NSSize 建议使用CG...
 */
/*
 1. 我们之前学习的结构体.
 NSRange
 CGPoint
 CGSize
 CGRect
 这些都是结构体, 他们的变量是无法存储到集合之中.
 2. 解决方案:
    先将这些结构体变量存储到OC对象中, 再将OC对象存储到集合之中.
 3. NSValue 类 的对象就是用来包装结构体变量的.
    NSValue *v1 = [NSValue valueWithRect: rect];
    NSLog(@"%@", NSStringFromRect(i.rectValue));
 */
/*
 1. NSDate 时间处理.
    1). 可以得到当前时间, 创建1个NSDate对象就可以了, 将这个对象输出, 就是当前时间.
        得到的是当前系统的格林威治时间. 0时区的时间. 东8区.
        NSDate *date = [NSDate date];
        NSLog(@"%@", date);
    2). 格式化输出日期, 指定日期输出的格式.
        默认的格式 年-月-日 时:分:秒 +时区.
        NSDate *date = [NSDate date];
        NSLog(@"%@", date);
        1. 先要创建1个NSDateFormatrer对象, 这个对象作用: 将1个日期转换成1个指定的格式.
        NSDateFormatrer *formatter = [[NSDateFormatrer alloc] init];
        2. 告诉这个日期格式化器对象 要把日期转换成什么样子的.
        yyyy: 年份
        MM: 月份
        mm: 分钟
        dd: 天
        hh: 12小时
        HH: 24小时
        ss: 秒
        formatter.dateFormat = @"yyyy年MM月dd日 HH点mm分ss秒";
        3. 使用日期格式化器 将指定的日期转换指定格式的字符串.
        NSString *str = [formatter stringFromDate: date];
        NSLog(@"str = %@", str);
    - (NSString *)stringFromDate:(NSDate *)date; //将日期类型转换为字符串
    - (NSDate *)dateFromString:(NSString *)string; //将字符串转换为日期对象
    注意: NSDate取到的时间是格林威治的时间.
         NSDateFormatter转换成字符串以后 会转换为当前系统的时区的时间.
 
 2. 计算时间
    1). 想得到明天此时此刻的时间.
        当前时间的基础之上 + 1天的时间.
        在当前时间的基础之上, 新增指定的时间, 得到的1个新的时间.
        + (instancetype)dateWithTimeIntervalSinceNow:(NSTimeInterval)secs;
        在当前的时间的基础之上, 新增指定的秒. 后的时间.
        得到东八区的时间:
        NSDate *d1 = [NSDate dateWithTimeIntervalSinceNow:8*60*60];
        传入1个负数 就是在当前时间的基础之上减指定的秒数.
    2). 求两个时间之间的差.
        可以实现的效果, 就是可以计算出执行代码所花费的时间.
        -(NSTimeInterval)timeIntervalSinceDate:(NSDate *)anotherDate;
 3. 得到NSDate中的年月日时分秒.
    1). 得到时间的各个部分, 可以使用日期格式化器来得到.
    2). 比较复杂.
    NSDate *date = [NSDate date];
    1. 创建1个日历对象, 调用类方法currentCalendar得到1个日历对象.
    NSCalendar *calendar = [NSCalendar currentCalendar];
    2. 指定日历对象取到日期的对象的那些部分, 是要取那1个时间对象的部分.
    返回1个日期组件对象, 这个对象中就有指定日期的指定部分.
    NSDateComponents *com = [calendar component:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDayFromDate:date];
    NSLog(@"%ld-%ld-%ld", com.year,com.month, com.day);
 */
/*
 1. 无论在MRC还是ARC下, 如果属性的类型是NSString类型的, @property参数使用copy.
 2. copy 复制
    1). copy是1个方法, 定义在NSObject类之中. 作用:拷贝对象.
        NSString --> copy --> 不可变字符串 没有产生新对象, 而是直接将对象本身的地址返回. 这种拷贝我们叫做浅拷贝
        NSMutableString --> copy --> 是1个不可变的字符串对象. 有产生1个新对象, 这样的拷贝我们叫做深拷贝.
    2). mutableCopy. 定义在NSObject类之中. 作用:拷贝对象.
        NSString --> mutableCopy --> 可变字符串对象. 深拷贝.
        NSMutableString --> mutableCopy --> 可变字符串对象. 深拷贝.
    这是字符串的对象拷贝特点.
 3. 字符串对象拷贝的引用计数器的问题.
    1). 若字符串对象存储在常量区中. 存储在常量区的数据是不允许被回收的.
        所以存储在常量区的字符串对象的引用计数器是1个超大的数, 并且retain和release无效.
    2). 若字符串存储在堆区, 这个字符串对象和普通的对象是一样的, 引用计数器默认是1.
    3). 字符串对象如果是浅拷贝. 会将对象的引用计数器+1
        字符串对象如果是深拷贝. 原来的对象的引用计数器不变. 新拷贝出来的对象的引用计数器为1.
 */
/*
 1. copy方法的确是定义在NSObject类中的1个方法.
    copy方法的内部调用了另外1个方法, copyWithZone:
    这个方法是定义在NSCopying协议之中的.
    因为我们的类没有遵守NSCopying协议, 那么我们的类中就没有copyWithZone:这个方法.
    所以, 当我们自定义的类调用copy方法的时候就会出错.
 2. 如果我们想要让我们自己的类具备对象拷贝的能力, 那么就让我们的类遵守NSCopying协议.
    并实现copyWithZone:这个方法.
    如果想要实现深拷贝: 那么就重新创建1个对象, 并将对象的属性的值复制, 返回.
    如果想要实现浅拷贝: 那么就直接返回self
 */
/*
 1. 单例模式
    1个类的对象, 无论在何时创建也无论在什么地方创建, 也无论创建多少次, 创建出来的都是同1个对象.
 2. 无论如何创建对象, 最终都会调用alloc方法来创建对象,
    1). alloc方法的内部, 其实什么都没有做, 只是调用了allocWithZone:方法.
    2). 实际上真正申请空间 创建对象的事情是allocWithZone:方法在做.
 3. 要实现单例模式.
    重写+ allocWithZone:
    + (instancetype)allocWithZone:(struct _NSZone *)zone{
        static id instance = nil;
        if (instance == nil){
            instance = [supper allocWithZone:zone];
        }
        return instance;
    }
 4. 单例模式的规范:
    如果类是1个单例模式, 要求为类提供1个类方法, 来返回这个单例对象.
    类方法的名称必须以 shared类名; default类名;
 5. 什么时候要把类搞成单例.
    1). 单例的特点:
        无论何时何地, 创建对象, 也不管创建多少次对象, 得到都是同1个对象.
        单例对象可以被共享, 存储在单例对象中的数据可以被共享.
        也就是无论在什么地方创建单例对象, 访问的都是同1个对象.
    2). 做游戏:
    游戏面板的宽度: 800
    游戏面板的高度: 600
    这两个数据基本上再很多的地方都会使用到.
    1. 直接写
    2. 宏, 程序运行的时候无法更改.
    3. 还是要定义为变量.
    定义为属性报错在对象中, 如果不是单例对象. 对象之间独立, 属性之间互不干扰.
    如果数据需要被整个程序所共享. 将数据以属性的方式存储在单例对象中.
 */
// 存储在磁盘上的任何文件都是以二进制的形式存储的.
// 第2个参数是文件的内容, 要求是文件的二进制的内容.
// NSData对象就是专门用来保存二进制数据的.    

//1. 先创建1个日期格式化对象, 这个对象可以将1个日期输出为指定的格式.
//2. 指定这个日期格式化对象 转换的格式.
// yyyy 代表年份 年份用4位表示.
// MM   代表月份 月份就会用2位表示.
// dd   天
// HH   时 24小时制
// hh   时 12小时制
// mm   分钟
// ss   秒
//3. 让格式化对象按照指定的格式将日期对象转换.
//   转换的时候会自动的转换为当前系统的时区的时间.
//需求: 将str赋值给p1.name属性以后.
//再修改str的值 不要影响p1.name
//解决: 在setter方法赋值的时候, 将传进来的对象先拷贝1份

    